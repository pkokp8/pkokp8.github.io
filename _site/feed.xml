<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>“pkokp8's Blog” - Articles</title>
		<description>在这个世界多搬点砖，如果能造一块那就太好了</description>
		<link>http://localhost:4000</link>
		<atom:link href="http://localhost:4000/feed.articles.xml" rel="self" type="application/rss+xml" />
		
			
			<item>
				<title>男厕所便池问题</title>
				
					<description>&lt;p&gt;某天在逛知乎。首页刷出了一道男厕所问题(这一定是知乎算法程序员的锅!)。由于网络问题有时候app回答刷不出来，需要退出重进一下。但退出重进后题目不见了，于是这题就困扰了我一个晚上。就百度那种搜索算法，搜的到这题就有鬼了。&lt;br /&gt;
题目是这样的：某处需要造一个男厕所。男厕所的便池样式是一排，且没有间隔，中间没有遮挡。&lt;br /&gt;
有这么几个前提：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;男人上厕所首先选择离门最近的&lt;/li&gt;
  &lt;li&gt;如果厕所中有人，为了没有来自左右的视线压力，则选择离人最远的位置&lt;/li&gt;
  &lt;li&gt;如果选择了离人最远的位置后会与人相邻，那么男人就会假装有事等待空位。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;举例：&lt;br /&gt;
1.只有1个男人时，不用说，1个便池&lt;br /&gt;
2.有2个男人时，3个。&lt;br /&gt;
3.有3个男人时，5个。&lt;br /&gt;
4.有4个男人时，并不是7个，而是8个。&lt;br /&gt;
如图男人是这么选择便池的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/便池/n=4_x=7.png&quot; alt=&quot;avatar&quot; /&gt;
只有7个便池时，第4人就需要等待了。&lt;br /&gt;
&lt;img src=&quot;/images/便池/n=4_x=8.png&quot; alt=&quot;avatar&quot; /&gt;
有8个便池时正好。&lt;/p&gt;

&lt;p&gt;问题来了，假设有n个男人要同时上厕所，那么最少需要几个便池？&lt;/p&gt;

&lt;p&gt;思来想去，觉得要么暴力算法：&lt;br /&gt;
最少的便池数量是每个男人间隔1个便池，也就是2n-1个。当数量达到每个男人间隔2个便池时，再增加1个就必定能容纳n+1个男人同时上厕所。&lt;br /&gt;
只要写一个函数从2n-1开始验证，直到3n-2时就能得出需要几个便池。但这个肯定不是最优算法！&lt;/p&gt;

&lt;p&gt;搜索了半天的百度，加了“知乎”的关键词也依然搜索不到。只能自己想解法。&lt;br /&gt;
首先想到的是递归。&lt;/p&gt;

&lt;h2 id=&quot;递归方法1&quot;&gt;递归方法1&lt;/h2&gt;
&lt;p&gt;n个男人需要3n-2个便池时，增加1个便池就能容纳n+1个男人。&lt;br /&gt;
于是得出n个男人需要的便池数量是(3m-2)+1，其中m=n-1&lt;br /&gt;
于是可以算出n个男人需要3n-4个&lt;br /&gt;
先不考虑n=1之类的临界条件，代入一个较大的数：&lt;br /&gt;
暴力穷举验证：&lt;br /&gt;
4个男人需要8个便池。3&lt;em&gt;4-4=8，完美&lt;br /&gt;
5个男人需要9个便池。3&lt;/em&gt;5-4=11，不完美了&lt;br /&gt;
这是因为不需要n-1个男人满足(3m-2)。&lt;br /&gt;
于是方法1错误。&lt;/p&gt;

&lt;h2 id=&quot;递归方法2&quot;&gt;递归方法2&lt;/h2&gt;
&lt;p&gt;n个男人需要X个便池。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;当n是奇数时，(n+1)/2个男人在X的前一半，(n+1)/2个男人在X的后一半。&lt;br /&gt;
&lt;img src=&quot;/images/便池/n.png&quot; alt=&quot;avatar&quot; /&gt;
只要得到前一半的数量，加上后一半的数量。此外由于中间的那个人算了两次，再减去1。那么结果就是n个男人需要的数量。&lt;br /&gt;
验证一下，假设算法为f&lt;br /&gt;
f(3)=f(2)+f(2)-1=3+3-1=5———成立&lt;br /&gt;
f(5)=f(3)+f(3)-1=5+5-1=9———成立&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;验证7个男人对14个便池&lt;br /&gt;
&lt;img src=&quot;/images/便池/n=7_x=14.png&quot; alt=&quot;avatar&quot; /&gt;
第7人没有位置&lt;br /&gt;
验证7个男人对15个便池&lt;br /&gt;
&lt;img src=&quot;/images/便池/n=7_x=15.png&quot; alt=&quot;avatar&quot; /&gt;
f(7)=f(4)+f(4)-1=8+8-1=15——–成立&lt;br /&gt;
因此f(n)=2*f((n+1)/2)-1&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;但是这个算法暂时还不满足n为偶数的情况。&lt;br /&gt;
当n为偶数，例如4。f(4)不能写作f(3)+f(2)-1=7 &lt;br /&gt;
因为这个方法是递归算前半段和后半段，前提是第3个人在中间位置。f(3)=5，f(2)=3，两者差值大于1。这样的分法不满足第3人在正中间。&lt;br /&gt;
为了保证左右两边的差值不大于1，取较大的半段即可。然后不但要减去重复计算的中间人，也要减去小半段取较大的半段的差值。即结果是f(n)=2*f(n/2+1)-2&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最终结果:&lt;br /&gt;
f(1)=1&lt;br /&gt;
f(2)=3&lt;br /&gt;
f(n)=2&lt;em&gt;f[(n+1)/2]-1      n为奇数&lt;br /&gt;
f(n)=2&lt;/em&gt;f(n/2+1)-2        n为偶数&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;
int toilet(int n)
{
	if(n == 1)
		return 1;
	if(n == 2)
		return 3;
	if(n &amp;amp; 1)
		return 2 * toilet( (n + 1)/2 ) - 1;
	else
		return 2 * toilet( n/2 + 1 ) - 2;
}
&lt;/pre&gt;

</description>
				
				<pubDate>Sun, 18 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/%E7%94%B7%E5%8E%95%E6%89%80%E4%BE%BF%E6%B1%A0%E9%97%AE%E9%A2%98</link>
				<guid isPermaLink="true">http://localhost:4000/%E7%94%B7%E5%8E%95%E6%89%80%E4%BE%BF%E6%B1%A0%E9%97%AE%E9%A2%98</guid>
			</item>
			
		
			
			<item>
				<title>uboot的网卡驱动</title>
				
					<description>&lt;p&gt;本人由于工作原因，接触过多款uboot。这里以香橙派开发板的uboot代码为例。&lt;br /&gt;
当然也可以直接取uboot的主页上下载一份最新的boot：http://www.denx.de/wiki/U-Boot/WebHome&lt;br /&gt;
关于香橙派的源码请去官网下载：http://www.orangepi.cn/downloadresourcescn/&lt;br /&gt;
或其git：https://github.com/orangepi-xunlong&lt;/p&gt;

&lt;h2 id=&quot;uboot网卡驱动&quot;&gt;uboot网卡驱动&lt;/h2&gt;

&lt;p&gt;uboot的启动流程是这样的：&lt;br /&gt;
cpu的片上rom会执行一段内部的代码，这段代码不可见、不可修改，一般是cpu厂家制作的。代码的功能是用来引导uboot。uboot的入口是start.S &lt;br /&gt;
start.S中都是一些汇编，cpu厂家会根据自己的uboot调整里面的一些逻辑，但大致流程依然是跳转执行board.c中的C语言的代码。&lt;br /&gt;
board.c的入口不确定。不同厂家会改接口名。例如sunxi的入口就是board_init_r，而海思则是start_armboot。要找到这个入口也很简单，因为一般没人改main.c–main_loop，谁调用了main_loop谁就是入口。&lt;br /&gt;
不过这次不是讲uboot的启动流程，主要讲网卡驱动的驱动流程。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;sunxi平台
在board_init_r入口处，有对网卡的初始化。以下就是一些简单的流程。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
board_init_r
	eth_initialize
		miiphy_init  //初始化一个mii_devs链表，并把current_mii指向NULL
		board_eth_init
			geth_initialize
				dev = (struct eth_device *)malloc(sizeof *dev);		//申请一个eth设备
				strcpy(dev-&amp;gt;name, &quot;eth0&quot;);							//命名为eth0
				random_ether_addr									//这个很有意思，随机产生一个mac地址
				//函数指针的初始化
				geth_sys_init										//sunxi平台会根据配置文件来初始化一些寄存器。
				eth_register										//注册一个eth。实际就是设定网卡结构体的状态等等。
				miiphy_register										//将mdio的操作注册进这个网卡结构体
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;海思平台
基本一样，稍有不同。因为都是基于官方boot修改的.手上只有一些笔记资料，就不放上来了。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;至此，网卡的初始化流程就结束了。如果配置都ok，那么只要再实现一个ping命令或tftp命令，就可以通过网卡和外界通信了。&lt;/p&gt;

&lt;h2 id=&quot;ping的流程&quot;&gt;ping的流程&lt;/h2&gt;
&lt;p&gt;uboot的ping命令非常简单。入口是do_ping。依然以香橙派的uboot为例。&lt;br /&gt;
用法和windows下或linux下是一样的。&lt;br /&gt;
do_ping首先把argv[1]赋值给NetPingIP，然后调用NetLoop(PING) 来初始化ping命令。&lt;/p&gt;

&lt;h1 id=&quot;netloop&quot;&gt;NetLoop&lt;/h1&gt;
&lt;p&gt;首先调用了eth_halt。然后设定网卡状态为ETH_STATE_PASSIVE。&lt;br /&gt;
调用eth_halt的原因我认为是uboot没有进程调度、中断的概念，万一网卡还在工作，可能导致此次调用不成功。因此需要直接重新初始化一次网卡驱动。&lt;br /&gt;
上面作了去初始化的操作，那么接下去一定会初始化网卡。&lt;/p&gt;

&lt;h1 id=&quot;eth_init&quot;&gt;eth_init&lt;/h1&gt;
&lt;pre&gt;
/* eth.c--eth_init */
		if (eth_current-&amp;gt;init(eth_current,bis) &amp;gt;= 0) {		//实际调用geth_init
			eth_current-&amp;gt;state = ETH_STATE_ACTIVE;
&lt;/pre&gt;

&lt;h1 id=&quot;netinitloop&quot;&gt;NetInitLoop&lt;/h1&gt;
&lt;p&gt;初始化网卡之后，这里取一些ping命令过程需要用到的参数给全局变量。例如netmask，ourip、gatewayip等等&lt;/p&gt;

&lt;h1 id=&quot;pingstart&quot;&gt;PingStart&lt;/h1&gt;
&lt;p&gt;获取到参数后，就需要发送ping消息了。这个接口是ping命令的实际工作函数的一小半。为什么说一小半呢？因为ping的流程是发送一个echo request，然后接收一个reply。并且发送request需要知道对端的mac地址。&lt;br /&gt;
此处甚至不知道对方的mac地址，也就没有办法把ping包发出去。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;PingSend–NetSetEther(pkt, mac, PROT_IP);
这个函数的作用是封装ethernet帧的头部，此处是ping包的一部分的封装。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
mac    ：目的host的mac，在这里全为0，因为现在只知道目的主机的ip，还不知道mac
PROT_IP: 该ethernet帧里封装的是IP包。ethernet帧分三种类型，根据ethernet的type来判断是哪种类型。
type:
PROT_IP 0x0800 /* IP protocol */
PROT_ARP 0x0806 /* IP ARP protocol */
PROT_RARP 0x8035 /* IP ARP protocol */
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;接下去继续封装icmp包：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
	ip = (volatile IP_t *)pkt;

	/*
	 * Construct an IP and ICMP header.
	 * (need to set no fragment bit - XXX)
	 */
	/* IP_HDR_SIZE / 4 (not including UDP) */
	ip-&amp;gt;ip_hl_v  = 0x45;
	ip-&amp;gt;ip_tos   = 0;
	ip-&amp;gt;ip_len   = htons(IP_HDR_SIZE_NO_UDP + 8);
	ip-&amp;gt;ip_id    = htons(NetIPID++);
	ip-&amp;gt;ip_off   = htons(IP_FLAGS_DFRAG);	/* Don't fragment */
	ip-&amp;gt;ip_ttl   = 255;
	ip-&amp;gt;ip_p     = 0x01;		/* ICMP */
	ip-&amp;gt;ip_sum   = 0;
	/* already in network byte order */
	NetCopyIP((void *)&amp;amp;ip-&amp;gt;ip_src, &amp;amp;NetOurIP);
	/* - &quot;&quot; - */
	NetCopyIP((void *)&amp;amp;ip-&amp;gt;ip_dst, &amp;amp;NetPingIP);
	ip-&amp;gt;ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE_NO_UDP / 2);
		s = &amp;amp;ip-&amp;gt;udp_src;		/* XXX ICMP starts here */
	s[0] = htons(0x0800);		/* echo-request, code */
	s[1] = 0;			/* checksum */
	s[2] = 0;			/* identifier */
	s[3] = htons(PingSeqNo++);	/* sequence number */
	s[1] = ~NetCksum((uchar *)s, 8/2);

	/* size of the waiting packet */
	NetArpWaitTxPacketSize =
		(pkt - NetArpWaitTxPacket) + IP_HDR_SIZE_NO_UDP + 8;

	/* and do the ARP request */
	NetArpWaitTry = 1;
	NetArpWaitTimerStart = get_timer(0);
&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;最后ArpRequest发送一个arp请求&lt;br /&gt;
调用NetSetEther(pkt, NetBcastAddr, PROT_ARP);&lt;br /&gt;
以及一些赋值，封装一个arp报文，最后通过eth_send发送出去。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;eth_send
实际调用了geth_initialize初始化的geth_xmit函数。功能就是不断的读写寄存器来获取网卡内的数据。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;发送完arp包之后，就回到了NetLoop。发送了arp之后会通过miiphy_link读取一下phy的MII_BMSR寄存器判断一下是否是link状态。&lt;/p&gt;
&lt;pre&gt;
#define MII_BMSR	    0x01	/* Basic mode status register  */
&lt;/pre&gt;
&lt;p&gt;如果此时读取寄存器错误或不是link状态，sunxi的boot就会点一下led灯来作指示。&lt;/p&gt;

&lt;p&gt;接下来就是ping的实际流程了。以下是一个死循环的开始&lt;br /&gt;
while(1)&lt;br /&gt;
{&lt;br /&gt;
首先是eth_rx，内部调用了geth_recv。看名字是一个接收网卡数据的接口。实际上sunxi的boot在网卡中对这块封装的不是很好，不知道为什么这么写。&lt;br /&gt;
这个接口不但有接收数据的操作(读写寄存器)，也有处理数据的操作(NetReceive)。&lt;br /&gt;
第一次读取时刚发送了arp请求，因此这里先会获取到一个arpreplay(case ARPOP_REPLY)&lt;br /&gt;
arp的作用是获取对端的物理地址(mac)&lt;br /&gt;
接收到arpreply后就得到了对方的mac地址，发送ping的剩余的数据即可。&lt;/p&gt;
&lt;pre&gt;
				(void) eth_send(NetArpWaitTxPacket,
						NetArpWaitTxPacketSize);
&lt;/pre&gt;
&lt;p&gt;这里NetArpWaitTxPacket在PingSend中已经初始化完成了，直接发送即可。&lt;/p&gt;

&lt;p&gt;NetLoop的第二次循环(不考虑失败情况)就应该能获取到ping的返回消息，也就是ICMP_ECHO_REPLY。这里很简单，调用了回调函数PingHandler，实际就是比较一下返回ip和argvp[1]的ip是否相等。相等时设定一下NetState为NETLOOP_SUCCESS。&lt;/p&gt;

&lt;p&gt;最后回到NetLoop，由于NetState状态被设为NETLOOP_SUCCESS，而NetBootFileXferSize在ping命令中一直为0.于是调用一下eth_halt关闭网卡，一个主要的ping流程就结束了。&lt;br /&gt;
}&lt;br /&gt;
根据返回的结果，打印“host argv[1] is alive\n”或者”ping failed; host argv[1] is not alive\n”&lt;/p&gt;

&lt;h2 id=&quot;todo&quot;&gt;TODO&lt;/h2&gt;
&lt;p&gt;实际上整个boot只实现了这些简单的发送返回的功能。复杂一点的就是tftp了。tftp虽然是基于udp的协议，但boot并没有封装的那么详细。&lt;br /&gt;
如果要实现一些tcp下的操作，只要了解tcp的消息构造，完全可以实现一个tcp的发送。（说的简单XD）&lt;br /&gt;
实现tcp发送后，可以在tcp的基础上实现http服务。&lt;br /&gt;
实现http服务后，就可以根据get、post等消息，实现一个不通过串口却能在boot下升级整个镜像的功能了。&lt;br /&gt;
不过要做这些，工作量巨大。那些在路由器上制作出了一个不死uboot的高手实在是厉害。&lt;/p&gt;

&lt;p&gt;=========&lt;br /&gt;
不过即使不懂这些东西，也有一个简单的框架，移植一下貌似就可以实现uboot下的http服务了。
uip，了解一下:)&lt;br /&gt;
游泳健身，了解一下XD&lt;/p&gt;

&lt;p&gt;=========&lt;br /&gt;
补充一下eth帧格式。markdown空格编辑太不优雅了。。。换张图片吧。&lt;br /&gt;
&lt;img src=&quot;/images/netdriver/netdriver.png&quot; alt=&quot;avatar&quot; /&gt;
Ethernet II和IEEE802.3的帧格式比较类似，主要的不同点在于前者定义的2字节的类型，而后者定义的是2字节的长度；所幸的是，后者定义的有效长度值与前者定义的有效类型值无一相同，这样就容易区分两种帧格式了。&lt;/p&gt;
</description>
				
				<pubDate>Sat, 17 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/uboot%E7%9A%84%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8</link>
				<guid isPermaLink="true">http://localhost:4000/uboot%E7%9A%84%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8</guid>
			</item>
			
		
			
			<item>
				<title>source和export</title>
				
					<description>&lt;h2 id=&quot;现象&quot;&gt;现象&lt;/h2&gt;

&lt;h1 id=&quot;testsh中将abc赋值为1&quot;&gt;test.sh中将ABC赋值为1&lt;/h1&gt;
&lt;p&gt;./test.sh之后echo $ABC的内容为空&lt;br /&gt;
source test.sh之后echo $ABC的内容为1&lt;/p&gt;

&lt;h1 id=&quot;在当前shell下赋值&quot;&gt;在当前shell下赋值&lt;/h1&gt;
&lt;p&gt;ABC=999&lt;br /&gt;
export AAA=998&lt;br /&gt;
在test.sh中将ABC和AAA都echo出来，得到的结果是&lt;br /&gt;
ABC为空，AAA为998&lt;/p&gt;

&lt;h2 id=&quot;原因&quot;&gt;原因&lt;/h2&gt;
&lt;p&gt;1.当我们执行脚本的时候，是当前终端所在的shell fork一个子shell然后执行，执行完了再返回终端所在的shell。&lt;br /&gt;
2.一个shell中的系统环境变量只对该shell或者它的子shell有效，该shell结束时变量消失（类似C语言的作用域）&lt;br /&gt;
3.source是在当前shell中执行&lt;/p&gt;

&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;1.export定义的变量只在当前shell下有效，对子shell是无效的。&lt;br /&gt;
2.脚本中定义变量，用source去执行，可以影响父shell&lt;/p&gt;

&lt;h2 id=&quot;通俗地讲&quot;&gt;通俗地讲&lt;/h2&gt;
&lt;p&gt;直接赋值影响当前shell&lt;br /&gt;
source可以影响父shell下的所有子shell、本身、本身的所有子shell&lt;br /&gt;
export只能通过影响自己、本身的子shell&lt;/p&gt;
</description>
				
				<pubDate>Sat, 17 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/shell%E7%9A%84source%E5%92%8Cexport</link>
				<guid isPermaLink="true">http://localhost:4000/shell%E7%9A%84source%E5%92%8Cexport</guid>
			</item>
			
		
			
			<item>
				<title>h264 h265码流分析</title>
				
					<description>&lt;h2 id=&quot;h264&quot;&gt;h264&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;SPS序列参数帧举例&lt;br /&gt;
00 00 00 01 67 64 。。。。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;PPS图像参数帧举例&lt;br /&gt;
00 00 00 01 68 EE。。。。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;I帧举例&lt;br /&gt;
00 00 00 01 65 EE。。。。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;P帧举例&lt;br /&gt;
00 00 00 01 61 E0 。。。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;00 00 00 01（也有00 00 01）分割之后的下一个字节就是NALU类型，将其转为二进制数据后第4~8位是nal单元类型&lt;/p&gt;

&lt;p&gt;int type = (code &amp;amp; 0x1f);&lt;br /&gt;
判断是否为I帧： （NALU类型  &amp;amp; 0001  1111） = 5，即是IDR slice。后面的数据即是I帧数据。不过单独的I帧无法解码，因为没有解码信息，是纯粹的裸数据。需要sps和pps才能解码。因此I帧前面一小段数据一定是SPS和PPS.当然也有可能有别的，例如sei等等&lt;/p&gt;

&lt;p&gt;具体nal类型如下：&lt;/p&gt;
&lt;pre&gt;
/* ffmpeg/libavcodec/h264.h */
enum {
    NAL_SLICE           = 1,
    NAL_DPA             = 2,
    NAL_DPB             = 3,
    NAL_DPC             = 4,
    NAL_IDR_SLICE       = 5,
    NAL_SEI             = 6,
    NAL_SPS             = 7,
    NAL_PPS             = 8,
    NAL_AUD             = 9,
    NAL_END_SEQUENCE    = 10,
    NAL_END_STREAM      = 11,
    NAL_FILLER_DATA     = 12,
    NAL_SPS_EXT         = 13,
    NAL_AUXILIARY_SLICE = 19,
    NAL_FF_IGNORE       = 0xff0f001,
};
&lt;/pre&gt;

&lt;h2 id=&quot;h265&quot;&gt;h265&lt;/h2&gt;

&lt;p&gt;基本同上，但解码方式有差异，&amp;amp;7E后需要右移1位&lt;br /&gt;
int type = (code &amp;amp; 0x7E)»1;&lt;/p&gt;

&lt;pre&gt;
/* ffmpeg/libavcodec/hevc.h */
enum NALUnitType {
    NAL_TRAIL_N    = 0,
    NAL_TRAIL_R    = 1,
    NAL_TSA_N      = 2,
    NAL_TSA_R      = 3,
    NAL_STSA_N     = 4,
    NAL_STSA_R     = 5,
    NAL_RADL_N     = 6,
    NAL_RADL_R     = 7,
    NAL_RASL_N     = 8,
    NAL_RASL_R     = 9,
    NAL_BLA_W_LP   = 16,
    NAL_BLA_W_RADL = 17,
    NAL_BLA_N_LP   = 18,
    NAL_IDR_W_RADL = 19,
    NAL_IDR_N_LP   = 20,
    NAL_CRA_NUT    = 21,
    NAL_VPS        = 32,
    NAL_SPS        = 33,
    NAL_PPS        = 34,
    NAL_AUD        = 35,
    NAL_EOS_NUT    = 36,
    NAL_EOB_NUT    = 37,
    NAL_FD_NUT     = 38,
    NAL_SEI_PREFIX = 39,
    NAL_SEI_SUFFIX = 40,
}
&lt;/pre&gt;

&lt;p&gt;举例：
       00 00 00 01 40  NALUnitType为 32  视频参数集         VPS&lt;br /&gt;
       00 00 00 01 42  NALUnitType为 33  序列参数集         SPS&lt;br /&gt;
       00 00 00 01 44  NALUnitType为 34  图像参数集         PPS&lt;br /&gt;
       00 00 00 01 4E  NALUnitType为 39  补充增强信息       SEI&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   00 00 00 01 26  NALUnitType为 19  IDR SLICE          I帧  
   00 00 00 01 02  NALUnitType为  1  非IDR SLICE        P帧  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同264，I帧前会有VPS/SPS/PPS&lt;/p&gt;
</description>
				
				<pubDate>Sat, 17 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/h264_h265%E7%A0%81%E6%B5%81%E5%88%86%E6%9E%90</link>
				<guid isPermaLink="true">http://localhost:4000/h264_h265%E7%A0%81%E6%B5%81%E5%88%86%E6%9E%90</guid>
			</item>
			
		
			
			<item>
				<title>gdb的简单使用</title>
				
					<description>&lt;ul&gt;
  &lt;li&gt;ulimit -c生成coredump&lt;/li&gt;
  &lt;li&gt;gdb processname coredump&lt;/li&gt;
  &lt;li&gt;bt 查看堆栈会看到“?”，表明这个进程无法追踪到符号表。可能是编译时或编译后为了缩小可执行文件的体积，strip了符号表&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
(gdb) bt
#0  0xb6f718e8 in ?? () from /lib/libxxx.so
#1  0xb6f71ed0 in ?? () from /lib/libxxx.so
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;symbol-file processname.sym
    &lt;blockquote&gt;
      &lt;p&gt;获取processname.sym文件到某个路径下&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;info sharedlibrary&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;
(gdb) info sharedlibrary 
From        To          Syms Read   Shared Object Library
0xb6eee2f4  0xb6f75a30  Yes (*)     /lib/libxxx.so
0xb6ec8f80  0xb6ed6c44  Yes (*)     /lib/libpthread.so.0
0xb6d0c870  0xb6deb4cc  Yes (*)     /lib/libyyy.so
0xb6ce3760  0xb6ce7238  Yes (*)     /lib/libzzz.so.1
&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;获取libxxx.so.sym文件到某个路径下&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;add-symbol-file libxxx.so.sym 0xb6eee2f4&lt;/li&gt;
  &lt;li&gt;bt 再次查看堆栈。此时”?”应该已经消失。如果还没有，继续上述步骤&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那么符号表怎么来？&lt;br /&gt;
编译时可以通过objcopy将符号表导出到其他位置。然后通过strip将可执行文件中的符号表去除。&lt;br /&gt;
这样有两个好处&lt;br /&gt;
1.减小了可执行文件的体积。&lt;br /&gt;
2.出问题了依然可以用gdb进行debug调试&lt;/p&gt;

&lt;pre&gt;
INPUT_PATH=$1			#设定可执行文件的路径
OUTPUT_PATH=$2			#设定输出符号表的路径

for i in `ls -X $INPUT_PATH`		#遍历可执行文件路径下的所有文件
do
	$OBJCOPY --only-keep-debug $INPUT_PATH/$i $OUTPUT_PATH/$i.sym	#objcopy导出符号表
	$STRIP $INPUT_PATH/$i											#strip去除符号表
	$STRIP --remove-section=.comment $INPUT_PATH/$i					#strip去除注释段
done
&lt;/pre&gt;

&lt;p&gt;具体其他操作可以找找objcopy和strip如何使用&lt;/p&gt;

&lt;p&gt;比如可以这么调试：&lt;/p&gt;
&lt;pre&gt;
gdb
(gdb) shell
cd image/
mv symbol/ lib/			#gdb默认从debug-file-directory的lib下导入符号表
exit
(gdb) set debug-file-directory image/
(gdb) nosharedlibrary
(gdb) sharedlibrary
(gdb) shell
./processname &amp;amp;
exit
(gdb) attach $(pifof processname)
(gdb) thread info
(gdb) thread 24
(gdb) c
(gdb) bt
(gdb) thread 24
(gdb) bt



&lt;/pre&gt;

</description>
				
				<pubDate>Sat, 17 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/gdb%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8</link>
				<guid isPermaLink="true">http://localhost:4000/gdb%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8</guid>
			</item>
			
		
			
			<item>
				<title>大喷子linus?</title>
				
					<description>&lt;ul&gt;
  &lt;li&gt;关于2018.1.2的intel cpu漏洞，linus是这么喷intel的：
A &lt;em&gt;competent&lt;/em&gt; CPU engineer would fix this by making sure speculation&lt;br /&gt;
doesn’t happen across protection domains. Maybe even a L1 I$ that is&lt;br /&gt;
keyed by CPL.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I think somebody inside of Intel needs to really take a long hard look&lt;br /&gt;
at their CPU’s, and actually admit that they have issues instead of&lt;br /&gt;
writing PR blurbs that say that everything works as designed.&lt;/p&gt;

&lt;p&gt;.. and that really means that all these mitigation patches should be&lt;br /&gt;
written with “not all CPU’s are crap” in mind.&lt;/p&gt;

&lt;p&gt;Or is Intel basically saying “we are committed to selling you shit&lt;br /&gt;
forever and ever, and never fixing anything”?&lt;/p&gt;

&lt;p&gt;Because if that’s the case, maybe we should start looking towards the&lt;br /&gt;
ARM64 people more.&lt;/p&gt;

&lt;p&gt;Please talk to management. Because I really see exactly two possibibilities:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Intel never intends to fix anything&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;OR&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;these workarounds should have a way to disable them.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Which of the two is it?&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;               Linus  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
				
				<pubDate>Thu, 15 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/linus%E5%8F%91%E8%A8%80</link>
				<guid isPermaLink="true">http://localhost:4000/linus%E5%8F%91%E8%A8%80</guid>
			</item>
			
		
			
			<item>
				<title>两种无损变长编码</title>
				
					<description>&lt;p&gt;最近看了下哥伦布编码，在此记录一下。&lt;br /&gt;
正好上一次写了libjpeg的解码。jpeg的编解码中涉及了一种编解码算法，叫做哈夫曼编码。这里也顺便讲一下。&lt;/p&gt;

&lt;h2 id=&quot;一阶无符号指数哥伦布编码&quot;&gt;一阶无符号指数哥伦布编码&lt;/h2&gt;
&lt;p&gt;264/265的编解码中，一些码流信息是通过哥伦布编码的方式编进码流的。&lt;br /&gt;
例如264的条带头解析中，表示IDR帧的序号是idr_pic_id，这个参数在264码流中是通过ue编码的，即无符号(u)指数(e)哥伦布编码&lt;br /&gt;
哥伦布编码有很多种变种，此处只讲一下一阶无符号指数哥伦布编解码。&lt;/p&gt;

&lt;h1 id=&quot;编码&quot;&gt;编码&lt;/h1&gt;
&lt;p&gt;例如对20进行ue编码&lt;br /&gt;
1.将X转换为二进制。20即10100。&lt;br /&gt;
2.对该值进行加1计算。得到10101&lt;br /&gt;
3.得到该二进制串的长度M。此处M=5&lt;br /&gt;
4.在码流前补充M-1个0。此处得到000010101&lt;/p&gt;

&lt;h1 id=&quot;解码&quot;&gt;解码&lt;/h1&gt;
&lt;p&gt;接下来对上述编码完的数据进行解码。&lt;br /&gt;
1.首先读取码流的连续N个0，直到遇到1为止。000010101有连续N=4个前导0
2.然后读取N+1位数据X。此处为10101
3.对X进行-1计算即得到了原始的码字。b(10101) - 1 = b(10100) = d(20)&lt;/p&gt;

&lt;p&gt;可以看出，这是一种无损编解码方式。编解码过程中没有精度的丢失。&lt;/p&gt;

&lt;h1 id=&quot;ffmpeg的哥伦布解码操作&quot;&gt;ffmpeg的哥伦布解码操作&lt;/h1&gt;
&lt;p&gt;先贴代码&lt;br /&gt;
todo：注释&lt;/p&gt;
&lt;pre&gt;
/* libavcodec/golomb.h */
static inline int get_ue_golomb(GetBitContext *gb)
{
    unsigned int buf;

    OPEN_READER(re, gb);
    UPDATE_CACHE(re, gb);
    buf = GET_CACHE(re, gb);

    if (buf &amp;gt;= (1 &amp;lt;&amp;lt; 27)) {
        buf &amp;gt;&amp;gt;= 32 - 9;
        LAST_SKIP_BITS(re, gb, ff_golomb_vlc_len[buf]);
        CLOSE_READER(re, gb);

        return ff_ue_golomb_vlc_code[buf];
    } else {
        int log = 2 * av_log2(buf) - 31;
        LAST_SKIP_BITS(re, gb, 32 - log);
        CLOSE_READER(re, gb);
        if (CONFIG_FTRAPV &amp;amp;&amp;amp; log &amp;lt; 0) {
            av_log(NULL, AV_LOG_ERROR, &quot;Invalid UE golomb code\n&quot;);
            return AVERROR_INVALIDDATA;
        }
        buf &amp;gt;&amp;gt;= log;
        buf--;

        return buf;
    }
}
&lt;/pre&gt;

&lt;h1 id=&quot;哥伦布编码好处&quot;&gt;哥伦布编码好处&lt;/h1&gt;
&lt;p&gt;与定长编码不同，哥伦布编码是一种变长编码。&lt;br /&gt;
对于定长编码，举个例子，需要编码一个数字0和一个数字4&lt;br /&gt;
假设数据处于0-255之间，那么可以使用unsigned char来存储这段数据&lt;br /&gt;
0就会被编码成0000 0000&lt;br /&gt;
4就会被编码成0000 0100&lt;br /&gt;
于是生成了一段二进制码流0000 0000 0000 0100&lt;br /&gt;
其中有效的信息是0和100&lt;/p&gt;

&lt;p&gt;那么对于哥伦布编码，会产生这样的码流：&lt;br /&gt;
0会被编码成1&lt;br /&gt;
4会被编码成00101&lt;br /&gt;
于是得到了一段码流100101&lt;/p&gt;

&lt;p&gt;可见，码流长度被大大的缩减了。&lt;br /&gt;
本来码流的长度是16个二进制位，现在只有6个。&lt;/p&gt;

&lt;p&gt;于是能得到一种结论：以后都用哥伦布编码不就行了？&lt;br /&gt;
不行！&lt;br /&gt;
哥伦布编码实际有效信息是除了前导0的部分，前导0是无效信息。而数字越小的部分，前导0越少，数字越大的部分，前导0越多。&lt;br /&gt;
假设一个0和一个0xffff ffff需要被编码，用u32来表示就是32个0和32个1。总长度是64。&lt;br /&gt;
但是用哥伦布编码就是1个1和32个0和1个1和32个0。结果总长度是66。&lt;br /&gt;
看得出此时反而使用定长编码较好，编解码方式也简单。&lt;/p&gt;

&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;那么什么时候可以用哥伦布编码呢？&lt;br /&gt;
一开始我认为，当需要被编码的数据【大概率】处于较小的值时，可以用哥伦布编码。&lt;br /&gt;
后来看到H264手册中存在类似这样的值：bit_depth_luma_minus8。这个值也是用哥伦布编码的。看到这个位的名字里有个minus8，虽然不知道这个值什么意思，但看名字应该是某个值-8后的值被编码了。&lt;br /&gt;
于是我认为，只要被编码的数据【大概率】分布于【某个区间】时，就可以用哥伦布编码。&lt;/p&gt;

&lt;p&gt;这是因为，假如数据99.99%的概率存在于0xffff fff0 - 0xffff ffff之间，剩下的数据是0 - 0xffff ffef平均分布的。只要对所有待编码的数据减去0xffff fff0操作。那么待编码的数据就变成了99.99%的概率分布于0-f。约定解码后加上0xffff fff0即可。&lt;/p&gt;

&lt;h2 id=&quot;哈夫曼编码&quot;&gt;哈夫曼编码&lt;/h2&gt;

&lt;h1 id=&quot;编码-1&quot;&gt;编码&lt;/h1&gt;
&lt;p&gt;假设有一段码流，为ABABDAABCD&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;统计各个码字出现的概率，并将码字按出现概率从大到小排序&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/huffman/huffman3.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;选取出现概率最小的两个码字（DC），构建一个根节点。左子节点的值左边那个码字（D），右子节点是右边那个码字（C）。根节点的值(假设为E)为DC的值相加。E替换DC的位置。
&lt;img src=&quot;/images/huffman/huffman1.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;继续上述步骤，直到生成一个根节点的值为所有值相加(A+B+C+D)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将所有左节点标记为0，右节点标记为1
&lt;img src=&quot;/images/huffman/huffman2.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;于是可以开始编码
A的编码为0&lt;br /&gt;
B的编码为10&lt;br /&gt;
C的编码为111&lt;br /&gt;
D的编码为110&lt;br /&gt;
ABABDAABCD的编码就是&lt;br /&gt;
0100101100010111110&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;解码-1&quot;&gt;解码&lt;/h1&gt;
&lt;p&gt;解码首先需要重建这颗haffman树。例如jpeg的DHT字段就含有重构huffman表的信息&lt;br /&gt;
然后去读取编码后的码流0100101100010111110&lt;br /&gt;
0是A，10是B，0是A，10是B，110是D，0是A，0是A，10是B，111是C，110是D&lt;br /&gt;
于是得到ABABDAABCD的原始码流&lt;/p&gt;

&lt;h1 id=&quot;总结-1&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;haffman的思想是在haffman树上方的节点，其码字在整段码流中出现的概率高，编码后的长度短。下方的出现概率低，编码后的长度长。&lt;/p&gt;

&lt;h2 id=&quot;两种编码方式的总结&quot;&gt;两种编码方式的总结&lt;/h2&gt;
&lt;p&gt;哈夫曼编码与哥伦布编码的思想比较接近，通过特定的规则，将出现概率大的数字编码成较短的码流。以达到减少数据量的目的。&lt;/p&gt;

</description>
				
				<pubDate>Wed, 14 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/%E4%B8%A4%E7%A7%8D%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81</link>
				<guid isPermaLink="true">http://localhost:4000/%E4%B8%A4%E7%A7%8D%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81</guid>
			</item>
			
		
			
			<item>
				<title>yuv的各种格式</title>
				
					<description>&lt;h2 id=&quot;pass&quot;&gt;pass&lt;/h2&gt;
</description>
				
				<pubDate>Tue, 13 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/yuv%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%BC%E5%BC%8F</link>
				<guid isPermaLink="true">http://localhost:4000/yuv%E7%9A%84%E5%90%84%E7%A7%8D%E6%A0%BC%E5%BC%8F</guid>
			</item>
			
		
			
			<item>
				<title>颜色渐变</title>
				
					<description>&lt;p&gt;打开了windows的cmd–mspaint工具。想选用一种颜色，点到了编辑颜色的地方。发现这颜色渐变很神奇，横向纵向的颜色都是变化的。 &lt;br /&gt;
&lt;img src=&quot;/images/颜色渐变/mspaint.png&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;于是决定写一份代码来实现这个颜色渐变的功能。&lt;br /&gt;
一开始很sb的认为rgb的渐变不是很简单嘛，rgb888的最大色是0xffffff，最小色是0x0。(0xffffff-0x0)/(w*h)得到每个像素点的变化step，然后跟随像素点的座标不断加step。&lt;br /&gt;
写完后发现不对。仔细一想，这特么不是sb是什么。渐变是两种分量颜色不变，一种颜色分量慢慢变化。前面的那种算法画出来的图像简直一坨翔，惨不忍睹（其实看多了也还好？）。&lt;br /&gt;
幸好windows的画图工具给了颜色编辑时的每个点的rgb值，观察规律。最后用c语言，生成了一副rgb裸数据的图像。图像可以用7yuv查看。&lt;/p&gt;

&lt;p&gt;话不多说，上代码。&lt;/p&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

#define WIDTH 1920
#define HEIGHT 1080
unsigned char dstrgb24[WIDTH*HEIGHT*3] = {0};


typedef enum _CHANG{
    ADDGERRN 	= 1,
    MINUSRED 	= 2,
    ADDBLUE 	= 3,
    MINUSGREEN 	= 4,
    ADDRED 		= 5,
    MINUSBLUE 	= 6,
    BUTT
}CHANGE;

int gwidth = WIDTH;
int gheight = HEIGHT;

#define abs(x) ((x)&amp;lt;0?(-1*(x)):(x))
int main()
{
    int pixel = 0;
    int x = 0;
    int y = 0;
    int startr, startg, startb;
    int endr, endg, endb;
    CHANGE flag = BUTT;
    for(y = 0; y &amp;lt; gheight; y++)
    {
        int r,g,b;
        int cnt = 0;
        startr = (-127) * y / gheight + 255;		//生成纵向最左侧的颜色
        startg = y * 127 / gheight;
        startb = y * 127 / gheight;
        endr = 255 - startr;						//这里取名有点误解，并不是右侧的end值，而是与start组成了颜色变化的范围
        endg = 255 - startg;
        endb = 255 - startg;

        r = startr;
        g = startg;
        b = startb;
        flag = ADDGERRN;
        for(x = 0; x &amp;lt; gwidth; x++)
        {
            double stepw = abs((endr - startr)) / (gwidth * 1.0);	//r,g,b的步长是一样的，用r计算就行了
            if(flag == ADDGERRN)					//观察画图工具的变化规律，最左侧是个定值，然后rgb分别变化，增加到最大值或减少到最大值后，进行下一个分量的变化。总共6种变化
            {
                g = startg + (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(g &amp;gt;= endg)
                {
                    cnt = 0;
                    g = endg;
                    flag++;
                }
            }
            else if(flag == MINUSRED)
            {
                r = startr - (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(r &amp;lt;= endr)
                {
                    cnt = 0;
                    r = endr;
                    flag++;
                }
            }
            else if(flag == ADDBLUE)
            {
                b = startb + (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(b &amp;gt;= endb)
                {
                    cnt = 0;
                    b = endb;
                    flag++;
                }
            }
            else if(flag == MINUSGREEN)
            {
                g = endg - (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(g &amp;lt;= startg)
                {
                    cnt = 0;
                    g = startg;
                    flag++;
                }
            }
            else if(flag == ADDRED)
            {
                r = endr + (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(r &amp;gt;= startr)
                {
                    cnt = 0;
                    r = startr;
                    flag++;
                }
            }
            else if(flag == MINUSBLUE)
            {
                b = endb - (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(b &amp;lt;= startb)
                {
                    cnt = 0;
                    b = startb;
                    flag++;
                }
            }
            else
            {
                //printf(&quot;???\n&quot;);
            }

            dstrgb24[pixel++] = r;
            dstrgb24[pixel++] = g;
            dstrgb24[pixel++] = b;
        }
    }
    FILE *fp = fopen(&quot;color.rgb&quot;, &quot;w+&quot;);
    if(fp != NULL)
    {
        fwrite(dstrgb24, gwidth * gheight * 3, 1, fp);
        fclose(fp);
    }
    printf(&quot;%d\n&quot;, pixel);
    return 0;

}

&lt;/pre&gt;

&lt;pre&gt;
[root@sf_share]# gcc color.c 
[root@sf_share]# ./a.out 
6220800
[root@sf_share]# ls color.rgb 
color.rgb

&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/images/颜色渐变/color.png&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;
</description>
				
				<pubDate>Thu, 08 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98-c</link>
				<guid isPermaLink="true">http://localhost:4000/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98-c</guid>
			</item>
			
		
			
			<item>
				<title>libjpeg解码篇</title>
				
					<description>&lt;p&gt;libjpeg是一个处理jpeg图像的开源库。实现了jpeg图片的编解码。源代码是用C语言写的。原始版本一直由IJG组织维护发布。&lt;/p&gt;

&lt;p&gt;本次先讲讲jpeg的解码。
既然是jpeg解码，那就先放一张图。图是从bing首页上爬下来的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libjpegmaterial/CactiIslaPescado_ZH-CN11317505000_1920x1080_orig.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;jpeg有非常多格式，后面的demo会拿上图作示例，不保证所有图片都能解码。&lt;br /&gt;
这是一张jfif格式的jpeg图像。&lt;/p&gt;

&lt;p&gt;这张图的格式是这样的：&lt;/p&gt;

&lt;pre&gt;
SOI				(0xFFD8)
APP0			(0xFFE0)
DQT				(0xFFDB)
DQT				(0xFFDB)
SOF0			(0xFFC0)
DHT				(0xFFC4)
DHT				(0xFFC4)
DHT				(0xFFC4)
DHT				(0xFFC4)
SOS				(0xFFDA)
实际图像的压缩数据
EOI				(0xFFD9)
&lt;/pre&gt;

&lt;p&gt;
然后话不多说，直接先放一段可以直接拿来用的libjpeg的sample代码。  
这段代码并没有经过仔细的优化，部分显示效果也并不是最佳。但作为初步认识libjpeg，应该够了吧。
&lt;/p&gt;
&lt;pre&gt;
int jpeg_to_yuv(unsigned char *jpeg_buffer,int insize, unsigned char **yuv_buffer, int *yuvlen)
{
	int a, i;
	int width, height;
	int r, g, b;
	int c,m,y,k;
	struct jpeg_decompress_struct cinfo;
	struct my_error_mgr jerr;
	JSAMPARRAY buffer;
	int row_stride;
	unsigned char *curptr = NULL;
	unsigned char *rgb24_buffer = NULL;

	cinfo.err = jpeg_std_error(&amp;amp;jerr.pub);  
//  	jerr.pub.error_exit = my_error_exit;

	if(setjmp(jerr.setjmp_buffer))
	{
		printf(&quot;my err %d\n&quot;, insize);
		jpeg_destroy_decompress(&amp;amp;cinfo);

		return 1;
	}

	jpeg_create_decompress(&amp;amp;cinfo);
	jpeg_mem_src(&amp;amp;cinfo, jpeg_buffer, insize);
	(void) jpeg_read_header(&amp;amp;cinfo, TRUE);

	//cinfo.out_color_space = JCS_YCbCr;
	//cinfo.raw_data_out = TRUE;

	
	(void) jpeg_start_decompress(&amp;amp;cinfo);

	int alignwidth = 0;
	if(cinfo.output_width % 16)
	alignwidth = cinfo.output_width / 16 * 16 + 16;
	else
	alignwidth = cinfo.output_width;

	row_stride = alignwidth * cinfo.output_components;
	width = alignwidth;
	height = cinfo.output_height;
	*yuvlen = width * height * 2;

	buffer = (*cinfo.mem-&amp;gt;alloc_sarray) ((j_common_ptr) &amp;amp;cinfo, JPOOL_IMAGE, row_stride, 1);

	rgb24_buffer = (unsigned char*)malloc(width * height * 3);
	memset(rgb24_buffer, 0, width * height * 3);
	printf(&quot;%d, color space %d\n&quot;, __LINE__, cinfo.out_color_space);

	if(cinfo.out_color_space == JCS_RGB)
	{
		curptr = rgb24_buffer;
		for(a = 0; a &amp;lt; height; a++)
		{
			(void) jpeg_read_scanlines(&amp;amp;cinfo, buffer, 1);

			for(i = 0; i &amp;lt; row_stride; i += 3)
			{
				r = (int)buffer[0][i];
				g = (int)buffer[0][i + 1];
				b = (int)buffer[0][i + 2];

				*curptr++ = r;
				*curptr++ = g;
				*curptr++ = b;
			}

		}
	}
	else if(cinfo.out_color_space == JCS_GRAYSCALE)
	{
		curptr = rgb24_buffer;
		for(a = 0; a &amp;lt; height; a++)
		{
			(void) jpeg_read_scanlines(&amp;amp;cinfo, buffer, 1);

			for(i = 0; i &amp;lt; row_stride; i += 1)
			{
				g = (int)buffer[0][i];

				*curptr++ = g;
				*curptr++ = g;
				*curptr++ = g;
			}

		}
	}
	else if(cinfo.out_color_space == JCS_CMYK)
	{
		curptr = rgb24_buffer;
		for(a = 0; a &amp;lt; height; a++)
		{
			(void) jpeg_read_scanlines(&amp;amp;cinfo, buffer, 1);

			for(i = 0; i &amp;lt; row_stride; i += 4)
			{
				c = (int)buffer[0][i];
				m = (int)buffer[0][i + 1];
				y = (int)buffer[0][i + 2];
				k = (int)buffer[0][i + 3];

				
				r = (k*c)/255;
				g = (k*m)/255;
				b = (k*y)/255; 
				 
				*curptr++ = r;
				*curptr++ = g;
				*curptr++ = b;
			}

		}
	}
	else
	{
		printf(&quot;jpg_to_yuv:unsupported jpeg color space %d, aborting.\n&quot;,  cinfo.out_color_space);
		return -1;
	}
	//(*cinfo.mem-&amp;gt;free_pool) ((j_common_ptr) &amp;amp;cinfo, JPOOL_IMAGE);

	/* rbgb24 to yuv */
	{
		*yuv_buffer = (unsigned char*)malloc(width * height * 2);
		RGB2YUV(rgb24_buffer, *yuv_buffer, height * width);
	}
	(void) jpeg_finish_decompress(&amp;amp;cinfo);

	jpeg_destroy_decompress(&amp;amp;cinfo);

	if(jerr.pub.num_warnings)
	{
		printf(&quot;jpg_to_yuv: jpeg lib warnings=%ld occurred\n&quot;, jerr.pub.num_warnings);
		return -1;
	}

	return 0;
}

&lt;/pre&gt;

&lt;p&gt;然后开始讲解一下这段代码。&lt;/p&gt;
&lt;h2 id=&quot;jpeg_std_error&quot;&gt;jpeg_std_error&lt;/h2&gt;

&lt;p&gt;这是一个异常处理函数相关的注册。libjpeg所有的异常返回，默认都是调用exit退出。也就是说如果发生了逻辑上的错误（流程、参数错误之类的），程序就直接就挂了，并且即使注册了信号处理函数都无法捕捉。&lt;br /&gt;
这在本地测试、使用时没什么问题，出错了定位一下，然后接着用。但生产环境中动不动就可能程序退出，还没什么日志，这怎么行？因此libjpeg也提供了一种方法，需要覆盖默认的error_exit函数指针。&lt;br /&gt;
例如提供一个my_error_exit函数通过jpeg_std_error注册进libjpeg。&lt;br /&gt;
在my_error_exit以及解码接口中通过setjmp/longjmp实现函数间的跳转。具体可以看一下example.c的实现。不难&lt;/p&gt;

&lt;h2 id=&quot;jpeg_create_decompress&quot;&gt;jpeg_create_decompress&lt;/h2&gt;
&lt;pre&gt;
/* jpeglib.h */
#define jpeg_create_decompress(cinfo) \
    jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, \
			  (size_t) sizeof(struct jpeg_decompress_struct))

&lt;/pre&gt;
&lt;p&gt;jpeg_create_decompress就是jpeg_CreateDecompress。函数实现在jdapimin.c中。&lt;br /&gt;
有一点需要提一下，源码文件前缀的命名，j是jpeg，c是compress，d是decompress。看解码相关的代码时，搜函数搜到的jc开头的文件里时一般可以忽略了。既不是c也不是d，但是j开头的，说明是公共文件。如果都不是，有可能是一个demo，也有可能是一些扩展功能，例如bmp函数相关的封装等。&lt;br /&gt;
进入这个函数内部一步步的看可以发现，这个create接口仅仅是向解码结构体j_decompress_ptr中注册一些函数指针，初始化一些数据结构，并且标记这个解码结构体的解码状态为DSTATE_START。解码状态是个一次解码中的全局标志位，可以通过解码结构体查询和设置。因为是单线程解码，没有锁的问题。&lt;/p&gt;
&lt;pre&gt;
/* Values of global_state field (jdapi.c has some dependencies on ordering!) */
#define CSTATE_START	100	/* after create_compress */
#define CSTATE_SCANNING	101	/* start_compress done, write_scanlines OK */
#define CSTATE_RAW_OK	102	/* start_compress done, write_raw_data OK */
#define CSTATE_WRCOEFS	103	/* jpeg_write_coefficients done */
#define DSTATE_START	200	/* after create_decompress */
#define DSTATE_INHEADER	201	/* reading header markers, no SOS yet */
#define DSTATE_READY	202	/* found SOS, ready for start_decompress */
#define DSTATE_PRELOAD	203	/* reading multiscan file in start_decompress*/
#define DSTATE_PRESCAN	204	/* performing dummy pass for 2-pass quant */
#define DSTATE_SCANNING	205	/* start_decompress done, read_scanlines OK */
#define DSTATE_RAW_OK	206	/* start_decompress done, read_raw_data OK */
#define DSTATE_BUFIMAGE	207	/* expecting jpeg_start_output */
#define DSTATE_BUFPOST	208	/* looking for SOS/EOI in jpeg_finish_output */
#define DSTATE_RDCOEFS	209	/* reading file in jpeg_read_coefficients */
#define DSTATE_STOPPING	210	/* looking for EOI in jpeg_finish_decompress */
&lt;/pre&gt;

&lt;h2 id=&quot;jpeg_mem_src&quot;&gt;jpeg_mem_src&lt;/h2&gt;
&lt;p&gt;jpeg_mem_src在libjpeg.so.62是不存在的。但在较新版本中存在这个接口。较新版本的libjpeg使用时遇到了一些问题，暂时没找到解决办法，因此就把新版本库中的这个接口移植了过来。移植方法很简单，新版本内搜一下这个函数，直接拿过来放在62版本同样的位置。编译一下，提示少定义函数了，就抄着新版本移植一下。提示少声明了，照着新版本声明一下。几分钟就搞定了。&lt;br /&gt;
这个接口的功能是将jpeg的内存数据送给解码结构体。入参除了解码结构体，还有一个buffer和一个size，显然buffer就是需要解码的jpegbuffer的指针，size就是长度。函数会把buffer和size注册给解码结构体内部的一个jpeg内存管理结构。此外就是注册一些内存管理的函数指针了。&lt;/p&gt;

&lt;h2 id=&quot;jpeg_read_header&quot;&gt;jpeg_read_header&lt;/h2&gt;
&lt;p&gt;看名字就可以知道，这个函数的功能是读取一下jpeg头。jpeg头中包含了很多解码需要的信息，例如huffman表，量化表，jpeg的长宽、位宽等等。&lt;br /&gt;
那么具体看一下，首先这个接口调用了jpeg_consume_input，接着根据返回值就返回了。联系函数名叫做readheader，那么jpeg_consume_input的返回值必定是JPEG_REACHED_SOS。否则如果是JPEG_REACHED_EOI（EOI，end of image），那干脆叫jpeg_decoder算了。&lt;/p&gt;
&lt;h1 id=&quot;jpeg_consume_input&quot;&gt;jpeg_consume_input&lt;/h1&gt;
&lt;pre&gt;
GLOBAL(int)
jpeg_consume_input (j_decompress_ptr cinfo)
{
  int retcode = JPEG_SUSPENDED;

  /* NB: every possible DSTATE value should be listed in this switch */
  switch (cinfo-&amp;gt;global_state) {
  case DSTATE_START:
    /* Start-of-datastream actions: reset appropriate modules */
    (*cinfo-&amp;gt;inputctl-&amp;gt;reset_input_controller) (cinfo);
    /* Initialize application's data source module */
    (*cinfo-&amp;gt;src-&amp;gt;init_source) (cinfo);
    cinfo-&amp;gt;global_state = DSTATE_INHEADER;
    /*FALLTHROUGH*/
  case DSTATE_INHEADER:
    retcode = (*cinfo-&amp;gt;inputctl-&amp;gt;consume_input) (cinfo);
    if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */
      /* Set up default parameters based on header data */
      default_decompress_parms(cinfo);
      /* Set global state: ready for start_decompress */
      cinfo-&amp;gt;global_state = DSTATE_READY;
    }
    break;
&lt;/pre&gt;
&lt;p&gt;里面就是个switch…case。首先解码状态在jpeg_create_decompress时被设为DSTATE_START，因此调用了reset_input_controller以及init_source，并标记解码状态为DSTATE_INHEADER。&lt;br /&gt;
接着调用consume_input，以及default_decompress_parms，并标记解码状态为DSTATE_READY。&lt;br /&gt;
reset_marker_reader看名字，叫做reset marker reader，外层函数叫做read header，显然就是用来重置解码结构体中marker相关的内容的。看进去也可以发现，没有实际的读取jpegbuffer。&lt;br /&gt;
init_source更简单，标记 ((my_src_ptr)cinfo-&amp;gt;src)-&amp;gt;start_of_file为true。意味着获取到了数据。那么显然主要操作在consume_input和default_decompress_parms中。&lt;br /&gt;
consume_input函数指针是jdinput.c–consume_markers函数。调用read_markers并返回JPEG_REACHED_SOS，接着调用initial_setup判断一下之前读出来的一些信息的合法性。&lt;/p&gt;
&lt;h1 id=&quot;read_markers&quot;&gt;read_markers&lt;/h1&gt;
&lt;p&gt;可以看到，这个函数就是个死循环。一开始unread_marker和saw_SOI都是0，先用first_marker读第一个标记M_SOI，并标记saw_SOI为TRUE，于是下一次就会调用next_marker，每次通过switch…case处理当前读到的标记下面的一段数据，直到读到M_SOS就会返回JPEG_REACHED_SOS。至于如何解析各个标记，可以去找一下jpeg的头的格式。网上资料还是比较详细的。&lt;/p&gt;
&lt;pre&gt;
	printf(&quot;unread_marker = %x\n&quot;, cinfo-&amp;gt;unread_marker);		//此处加一句打印
    /* At this point cinfo-&amp;gt;unread_marker contains the marker code and the
     * input point is just past the marker proper, but before any parameters.
     * A suspension will cause us to return with this state still true.
     */
    switch (cinfo-&amp;gt;unread_marker) {
&lt;/pre&gt;
&lt;p&gt;就可以看到文章最开始的那张图像会打印如下信息。&lt;/p&gt;
&lt;pre&gt;
unread_marker = d8
unread_marker = e0
unread_marker = db
unread_marker = db
unread_marker = c0
unread_marker = c4
unread_marker = c4
unread_marker = c4
unread_marker = c4
unread_marker = da
&lt;/pre&gt;
&lt;p&gt;例如根据jpeg的格式，一张jpeg的宽高可以从sof标记后面的数据得到：
&lt;img src=&quot;/images/libjpegmaterial/1.jpg&quot; alt=&quot;avatar&quot; /&gt;
1920=0x0780&lt;br /&gt;
1080=0x0438&lt;br /&gt;
当然并不是所有jpeg图像都有上述的各个标记。具体图像具体分析。&lt;br /&gt;
最终read_markers将返回值JPEG_REACHED_SOS返回到jpeg_consume_input中，会接着执行default_decompress_parms。&lt;br /&gt;
根据default_decompress_parms的注释，这段代码是一个猜测的经验值，并没有规定一定是这样。jpeg_color_space是输入的jpeg的色彩空间。out_color_space是输出的。
&lt;img src=&quot;/images/libjpegmaterial/2.jpg&quot; alt=&quot;avatar&quot; /&gt;
最上方的这张图的输入是JCS_YCbCr，输出在此处被设为了JCS_RGB。理论上如果需要实现解码成yuv，那么此处应该设置输出为JCS_YCbCr。这个后面再讲。(1)&lt;br /&gt;
最终设置一些默认解码参数，例如raw_data_out为false，dct_method为JDCT_DEFAULT，scale比例为1等等，之后函数就结束了。&lt;br /&gt;
最终jpeg_consume_input标记解码状态为DSTATE_READY，jpeg_read_header就正常的结束了。&lt;/p&gt;

&lt;h2 id=&quot;jpeg_start_decompress&quot;&gt;jpeg_start_decompress&lt;/h2&gt;
&lt;p&gt;调用jinit_master_decompress初始化master。这是个私有数据，可以暂不关心。并标记解码状态为DSTATE_PRELOAD。&lt;br /&gt;
progress这个函数指针是注册一个进度处理函数，可以显示进度。一般可以不注册，那么就忽略。&lt;br /&gt;
而has_multiple_scans标记位，看名字意思是jpeg图像中有多个扫描。上面这张图并没有这个特征。&lt;br /&gt;
接着调用output_pass_setup就可以返回了。&lt;/p&gt;
&lt;h1 id=&quot;output_pass_setup&quot;&gt;output_pass_setup&lt;/h1&gt;
&lt;p&gt;注意此处的解码状态依然是DSTATE_PRELOAD，因此会调用prepare_for_output_pass。is_dummy_pass在jinit_master_decompress时被初始化为false，因此下面其实是个不执行的循环，意思是prepare_for_output_pass执行完就基本返回了。&lt;br /&gt;
prepare_for_output_pass中首先和上面说的一样，is_dummy_pass是false，default_decompress_parms会把quantize_colors设为false，colormap设为NULL；jpeg_create_decompress会把progress设为NULL。&lt;br /&gt;
于是，此处相当于只执行了以下内容：&lt;/p&gt;
&lt;pre&gt;
    (*cinfo-&amp;gt;idct-&amp;gt;start_pass) (cinfo);
    (*cinfo-&amp;gt;coef-&amp;gt;start_output_pass) (cinfo);
    if (! cinfo-&amp;gt;raw_data_out) {
      if (! master-&amp;gt;using_merged_upsample)
	(*cinfo-&amp;gt;cconvert-&amp;gt;start_pass) (cinfo);
      (*cinfo-&amp;gt;upsample-&amp;gt;start_pass) (cinfo);
      if (cinfo-&amp;gt;quantize_colors)
	(*cinfo-&amp;gt;cquantize-&amp;gt;start_pass) (cinfo, master-&amp;gt;pub.is_dummy_pass);
      (*cinfo-&amp;gt;post-&amp;gt;start_pass) (cinfo,
	    (master-&amp;gt;pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
      (*cinfo-&amp;gt;main-&amp;gt;start_pass) (cinfo, JBUF_PASS_THRU);
}
&lt;/pre&gt;
&lt;p&gt;可以看出都是一些start pass。说明并不是实际的进行一些解码变换。否则应该叫idct-&amp;gt;process。&lt;br /&gt;
举个例子，idct-&amp;gt;start_pass注册为jddctmgr.c–start_pass，看一下大致的流程，仅仅是初始化一些查询表，不作解码动作。&lt;br /&gt;
raw_data_out在default_decompress_parms时被设为false，因此最终解码状态为DSTATE_SCANNING。如果手动设置了raw_data_out（见上(1)），那么此处可能是DSTATE_RAW_OK。&lt;br /&gt;
不管怎么说，jpeg_start_decompress就正确的返回了。&lt;/p&gt;

&lt;h2 id=&quot;jpeg_read_scanlinesjpeg_read_raw_data&quot;&gt;jpeg_read_scanlines/jpeg_read_raw_data&lt;/h2&gt;
&lt;p&gt;根据解码状态，显然接下去应该调用jpeg_read_scanlines解码。也有可能调用jpeg_read_raw_data解码。&lt;br /&gt;
如果要详细讲这两个函数，那么显然要了解jpeg的编码、解码方式。由于我的能力有限，暂未能详细了解jpeg的编解码流程，因此此处暂且不讲具体流程，仅仅简单的分析一下。&lt;br /&gt;
这两个函数处于jdapistd.c中，并且是紧挨着的两个函数。说明功能其实差不多。&lt;/p&gt;
&lt;h1 id=&quot;jpeg_read_scanlines&quot;&gt;jpeg_read_scanlines&lt;/h1&gt;
&lt;p&gt;调用process_data–process_data_simple_main。而process_data_simple_main调用decompress_data和post_process_data。&lt;/p&gt;
&lt;h1 id=&quot;jpeg_read_raw_data&quot;&gt;jpeg_read_raw_data&lt;/h1&gt;
&lt;p&gt;直接调用decompress_data。&lt;/p&gt;

&lt;h1 id=&quot;post_process_data&quot;&gt;post_process_data&lt;/h1&gt;
&lt;p&gt;虽然细节上还有差异，但显然差异就在于post_process_data。&lt;br /&gt;
post-&amp;gt;pub.post_process_data —- cinfo-&amp;gt;upsample-&amp;gt;upsample —- (jdsample.c)sep_upsample&lt;br /&gt;
sep_upsample中调用了两个接口，methods以及color_convert。methods是一些采样方法，暂且忽略。color_convert就是色彩空间的转换。&lt;br /&gt;
jinit_master_decompress-master_selection-jinit_color_deconverter中会根据输入的jpeg色彩空间以及输出的色彩空间（之前默认rgb），设置color_convert函数指针为&lt;br /&gt;
grayscale_convert&lt;br /&gt;
ycc_rgb_convert&lt;br /&gt;
gray_rgb_convert&lt;br /&gt;
null_convert&lt;br /&gt;
ycck_cmyk_convert&lt;br /&gt;
之一。那么如果要解码成JCS_YCbCr（见上(1)），输入又是JCS_YCbCr，那么显然调用jpeg_read_raw_data速度会更快。否则jpeg_read_scanlines会将yuv变换为rgb。后面又要通过rgb转换回yuv(demo写的不够好)。&lt;/p&gt;

&lt;h2 id=&quot;色彩空间&quot;&gt;色彩空间&lt;/h2&gt;
&lt;p&gt;上面这段demo支持rgb、gray、cmyk的解码。其中rgb和gray的解码效果基本没有差异，唯独cmyk有点缺陷。&lt;/p&gt;

&lt;p&gt;demo解码  :
&lt;img src=&quot;/images/libjpegmaterial/8.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;XnView解码  :
&lt;img src=&quot;/images/libjpegmaterial/9.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;windows照片查看器  :
&lt;img src=&quot;/images/libjpegmaterial/10.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ffplay CactiIslaPescado_ZH-CN11317505000_1920x1080_cmyk.jpg -x 1280 -y 720  :
&lt;img src=&quot;/images/libjpegmaterial/12.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;photoshop  :
&lt;img src=&quot;/images/libjpegmaterial/13.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看得出，除了photoshop和windows，其他的解码效果都与原图色彩较深。这是因为rgb于cmyk的转换并不是点对点的无损转换。
&lt;img src=&quot;/images/libjpegmaterial/14.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有一种做法是将当前cmyk的色域扩充到lab色域。然后再缩回rgb色域。这样效果会较好（未经过验证）。&lt;/p&gt;

&lt;h2 id=&quot;jpeg_finish_decompressjpeg_destroy_decompress&quot;&gt;jpeg_finish_decompress/jpeg_destroy_decompress&lt;/h2&gt;
&lt;p&gt;一般来说，完成解码会调用这两个接口进行资源回收。但如果需要反复的解码，建议jpeg_create_decompress之前的代码只执行一次。此处只执行jpeg_finish_decompress，不执行jpeg_destroy_decompress。&lt;br /&gt;
jpeg_finish_decompress的内部会调用jpeg_abort进行一些资源回收。不调用jpeg_abort会出现内存泄漏问题。&lt;br /&gt;
jpeg_abort很奇怪的位于jcomapi.c中&lt;/p&gt;

&lt;p&gt;至此，一段简单的jpeg解码流程就结束了。欢迎和我讨论: pkokp8@gmail.com&lt;br /&gt;
编码流程有空继续补充。&lt;/p&gt;

</description>
				
				<pubDate>Mon, 05 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/libjpeg-decode-c</link>
				<guid isPermaLink="true">http://localhost:4000/libjpeg-decode-c</guid>
			</item>
			
		
			
			<item>
				<title>git的简单操作</title>
				
					<description>&lt;p&gt;
  记录一下git的使用。系统是ubuntu16.04. 安装好git环境  
  首先在github上右上角点一下+，然后New repository。  
  也可以本地创建好后push上去，不过这样也挺方便的。初学者嘛
&lt;/p&gt;

&lt;p&gt;
  然后是clone一个master，例如刚才创建的pkokp8.github.io.git分支
&lt;/p&gt;
&lt;pre&gt;
# git clone https://github.com/pkokp8/pkokp8.github.io.git
&lt;/pre&gt;

&lt;p&gt;接着就可以修改、提交文件&lt;/p&gt;
&lt;pre&gt;
# echo &quot;# test info&quot; &amp;gt;&amp;gt; README.md           #新建README.md
# git add .                                 #本地仓库新增这个文件
# git commit -m &quot;commit the readme&quot;         #提交到本地，日志为-m后面&quot;&quot;内的字符串。万一commit错误，可以不进行下一步，直接使用reset来回退代码，这样远端就不会有这次commit的记录
# git push -u origin master                 #push到远程主线。
&lt;/pre&gt;

&lt;p&gt;
  此时可能因为没有用户名和密码，会提示错误。可以配置后再执行上述命令
&lt;/p&gt;

&lt;pre&gt;
# git config --global user.name &quot;pkokp8&quot;
# git config --global user.email &quot;xxx@xx.com&quot;
&lt;/pre&gt;

&lt;p&gt;
  查看本地的提交记录，简单的可以使用。配合reset可以回退版本。注意-hard会把本地修改覆盖掉。  
  类似svn的svn revert ./ -R;svn up -r xxx
&lt;/p&gt;
&lt;pre&gt;
# git log
commit af17a9f424c5da5b4b06f90e69eb069f89124e40
Author: pkokp8 &amp;lt;xxx@xx.com&amp;gt;
Date:   Thu Mar 1 00:23:55 2018 +0800

    modify readme

# git reset -hard af17a9f424c5da5b4b06f90e69eb069f89124e40 
&lt;/pre&gt;

&lt;p&gt;
  接着就可以创建分支了：
&lt;/p&gt;
&lt;pre&gt;
# git branch firstversion                   #创建名为firstversion的分支
# git checkout firstversion                 #切换到这个分支
# git push -u origin firstversion           #把这个分支push到远端
# git checkout master                       #切换回主线
# git branch                                #查看当前处于哪条分支（看*），以及存在哪些分支
  firstversion
* master
# git diff                                  #查看本地与本地仓库之间的差异
&lt;/pre&gt;

&lt;p&gt;
  暂时就用到这么多。我感觉我还是要学习一个
&lt;/p&gt;
</description>
				
				<pubDate>Thu, 01 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/git-simple-use</link>
				<guid isPermaLink="true">http://localhost:4000/git-simple-use</guid>
			</item>
			
		
			
			<item>
				<title>python爬虫</title>
				
					<description>&lt;h2 id=&quot;一个bing的爬虫&quot;&gt;一个bing的爬虫&lt;/h2&gt;
&lt;p&gt;作用仅限于下载一张首页的背景图。拿来作作windows桌面效果还不错。&lt;/p&gt;

&lt;pre&gt;

from urllib import request
import re

bingeverydayimgprefix  = 'https://www.bing.com/az/hprichbg/rb/'

with request.urlopen('https://www.bing.com/') as f:
    data = f.read()
    #print('Status:', f.status, f.reason)
    for k, v in f.getheaders():
        pass
    bingdata = data.decode('utf-8')

def findimg(htmlstring):
    return re.findall(r'\.jpg', htmlstring)

print(&quot;===================&quot;)
bracket = re.findall(r'\{.*?\}', bingdata)
cnt = 0
jpglist=[]
for i in bracket:
    if findimg(i):
        cnt += 1
        jpglist.append(i)

print(&quot;here has %d jpg element(s)&quot; % cnt)
truejpegurl=[]
jpegfilename=[]
for i in jpglist:
    result = [x for x in re.split(&quot;/|\'|\&quot;&quot;, i) if x]
    for j in result:
        if findimg(j):
            truejpegurl.append(bingeverydayimgprefix + j)
            jpegfilename.append(j)
print(truejpegurl)
print(jpegfilename)

print(&quot;===========================================================&quot;)
import urllib.request

def getImg(url,filename):
    urllib.request.urlretrieve(url, filename)

n=0
for cururl in truejpegurl:
    getImg(truejpegurl[n], jpegfilename[n])
    n += 1

&lt;/pre&gt;

&lt;h2 id=&quot;一个http请求的发送&quot;&gt;一个http请求的发送&lt;/h2&gt;
&lt;p&gt;bing到底和作者什么仇？&lt;/p&gt;
&lt;pre&gt;
import socket

# 创建socket:
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
# 连接:

s.connect(('www.bing.com', 80))

request = 'GET / HTTP/1.1 \r\n\
Host: cn.bing.com\r\n\
User-Agent:Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50\r\n\
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\r\n\
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\r\n\
Connection: close\r\n\
Upgrade-Insecure-Requests: 1\r\n\
Pragma: no-cache\r\n\
Cache-Control: no-cache\r\n\r\n'

s.send(bytes(request, encoding = &quot;utf8&quot;))

# 接收:
buffer = []
while True:
    d = s.recv(1024)
    if d:
        buffer.append(d)
    else:
        break
data = b''.join(buffer)

s.close()

header, html = data.split(b'\r\n\r\n', 1)
print(header.decode())
with open('bing.html', 'wb') as f:
    f.write(html)
&lt;/pre&gt;

&lt;h2 id=&quot;爬爬漫画&quot;&gt;爬爬漫画&lt;/h2&gt;
&lt;p&gt;实测效果不是很好。跑了一下午一部《死神》都没爬完。还需要继续培养面向对象的编程思想。而且总是用正则，代码不简洁；应该有第三方模块可以直接import后处理获取到的一些数据
只实现了imanhua的一小部分，manhuatai还没有实现。&lt;/p&gt;

&lt;pre&gt;
#coding=utf-8
from urllib import request
import re
import base64
import os
from selenium import webdriver
#browser = webdriver.PhantomJS()

class manhuatai(object):      ####todo
    def __init__(self, url):
        self.url = url
    def introduce(self):
        with request.urlopen(self.url) as f:
            data = f.read()
            # print('Status:', f.status, f.reason)
            for k, v in f.getheaders():
                pass
            self.urldata = data.decode('utf-8')                                                                 #manhuatai用了utf-8编码，因此decode参数为utf-8
            self.urldatalist = []
            bracket=re.findall(r'\&amp;lt;.*?\&amp;gt;', self.urldata)
            for i in bracket:
                self.urldatalist.append(i)
                #print(i)
    def setepisode2dict(self):
        self.episodedict = {}
        for i in self.urldatalist:
            m = re.match(r'^.*?title\=\&quot;(.*?)\&quot;\s.*?\&quot;(.*\.html)\&quot;.*$', i)
            if m:
                self.episodedict[m.group(1)]=m.group(2)
                #print(&quot;{}==={}&quot;.format(m.group(1),m.group(2)))


    def requestepisode(self):
        print(self.url + '/' + self.episodedict['第01期'])
        with request.urlopen(self.url + '/' + self.episodedict['第01期']) as f:
            data = f.read()
            # print('Status:', f.status, f.reason)
            #for k, v in f.getheaders():
            #    pass
            episodedata = data.decode('utf-8')
            print(episodedata)                                                                                  #找不到每一张图片的url请求，先搁置
        browser.get(self.url + '/' + self.episodedict['第01期'])                                                #用webdriver的方法去请求，实际PhantomJS是一个无界面的浏览器内核
        print(&quot;need open line 6&quot;)
        data = browser.page_source                                                                              #页面源码
        #print(data)

    def getImg(self, url,filename):
        request.urlretrieve(url, filename)

class iimanhua(manhuatai):
    def introduce(self):
        with request.urlopen(self.url) as f:                                                                    #请求介绍页，获取漫画列表
            data = f.read()
            # print('Status:', f.status, f.reason)
            for k, v in f.getheaders():
                #print(&quot;{}={}&quot;.format(k, v))
                pass
            #print(data.decode('gb2312', errors='ignore'))                                                      #imanhua网站用了gb2312编码，因此decode参数为gb2312
            self.urldata = data.decode('gb2312', errors='ignore')
            self.urldatalist = []
            bracket=re.findall(r'\&amp;lt;.*?\&amp;gt;', self.urldata)
            for i in bracket:
                self.urldatalist.append(i)
                #print(i)
    def getImg(self, url,filename):
        request.urlretrieve(url, filename)
    def setepisode2dict(self):                                                                                  #将每一话的相对路径和标题存入self.episodedict
        self.episodedict = {}
        for i in self.urldatalist:
            m = re.match(r'^.*?\&quot;(\/imanhua.*?\.html)\&quot;\s+title=\&quot;(.*?)\&quot;.*?target.*$', i)
            if m:
                self.episodedict[m.group(2)]=m.group(1)
                #print(&quot;{}={}&quot;.format(m.group(1),m.group(2)))

        for k, v in self.episodedict.items():
            pass
            #print(&quot;{}={}&quot;.format(k, v))    #第x话='xxx.html'
    def requestepisode(self):                                                                                   #处理每一话
        self.mainurl='http://www.iimanhua.com/'
        for k, v in self.episodedict.items():
            print(&quot;{}={}&quot;.format(k,v))
            with request.urlopen(self.mainurl + '/' + v) as f:                                                          #打开每一话的第一页，每张图片是异步加载的。但是页面源码可以获取base64编码的图片url
            #with request.urlopen('http://www.iimanhua.com/imanhua/9202/261288.html') as f:
                data = f.read()
                self.episode = data.decode('gb2312', errors='ignore')
                m = re.findall(r'var\sqTcms_S_m_murl_e=\&quot;(.*?)\&quot;;', self.episode)
                #print(self.episode)
                allpicurl = str(base64.urlsafe_b64decode(m[0]), encoding = &quot;utf-8&quot;).split('$qingtiandy$')               #将var qTcms_S_m_murl_e='xxx'的内容进行base64解码，并通过$qingtiandy$分割
                print(allpicurl)                                                                                            #这就是实际图片的url的一个list
                cnt=1
                if os.path.exists(k) != True:
                    os.mkdir('{}\\{}'.format('sishen', k))                                                              #创建一个文件夹存储下载的图片数据.现在只支持死神。若要添加其他的，需要修改此处以及下方sishen以及class的url
                for i in allpicurl:
                    try:
                        self.getImg('http://www.iimanhua.com/' + i, &quot;{}\\{}\\{}.jpg&quot;.format('sishen', k, cnt))      #实际下载。部分图片url是相对地址，需要加前缀
                    except BaseException:
                        try:
                            self.getImg(i, &quot;{}\\{}\\{}.jpg&quot;.format('sishen', k, cnt))                                   #部分url是绝对地址，不需要加前缀
                        except BaseException:
                            print(&quot;something err, ignore&quot;)                                                              #图片会下载失败，可能是服务器缘故，先这样处理
                            break
                    cnt+=1





comic=iimanhua(&quot;http://www.iimanhua.com/imanhua/sishen/&quot;)
comic.introduce()
comic.setepisode2dict()
comic.requestepisode()
#comic.getImg(&quot;http://cartoon.youzu88.com/manhuatuku/106/manhua_12_20160717_2016071711302992378.jpg&quot;, &quot;1.jpg&quot;)


#browser.close()
&lt;/pre&gt;
</description>
				
				<pubDate>Wed, 28 Feb 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/python%E7%88%AC%E8%99%AB</link>
				<guid isPermaLink="true">http://localhost:4000/python%E7%88%AC%E8%99%AB</guid>
			</item>
			
		
			
			<item>
				<title>复制一个list</title>
				
					<description>&lt;p&gt;初学python，爬图片的时候想复制一个list。一开始以为可以直接用这种方式复制list：
&lt;/p&gt;

&lt;pre&gt;
lista=[xxx, yyy, zzz]
listb=lista
&lt;/pre&gt;

&lt;p&gt;后来发现修改listb后lista的值也被修改了。原因是实际上listb就是lista。&lt;/p&gt;
&lt;p&gt;可以尝试用id函数打印出两个list的内存地址:&lt;/p&gt;
&lt;pre&gt;
lista = [0, 1, 2, 3, 4]
print(&quot;%s %s&quot; % (lista, id(lista)))

listb = lista
print(&quot;%s %s&quot; % (listb, id(listb)))

=============================
[0, 1, 2, 3, 4] 8246256
[0, 1, 2, 3, 4] 8246256

&lt;/pre&gt;

&lt;p&gt;
看得出，id相同。说明了两个list其实是同一个引用，这肯定不行。目的是为了新建一个list，同时修改新建的list不影响之前的list    
&lt;/p&gt;
&lt;p&gt;
有一种办法很粗暴：for循环遍历旧的list，新建一个空list，然后通过append方法把每一个元素添加进新的list。于是代码就是：
&lt;/p&gt;
&lt;pre&gt;
listnew=[]
for i in listold:
    listnew.append(i)
&lt;/pre&gt;
&lt;p&gt;
这个方法类似于在c语言中写出这样的代码:
&lt;/p&gt;
&lt;pre&gt;
char old[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
char new[10];
int i = 0;
for(i = 0;i &amp;lt; sizeof(old)/sizeof(char); i++)
{
	new[i] = old[i];
}
&lt;/pre&gt;
&lt;p&gt;你退群吧。除非要对数组每个成员进行处理，否则遍历有什么意义，memcpy()不行吗？&lt;/p&gt;
&lt;p&gt;而对于python来说，复制一个list有一些巧妙方法，例如：&lt;/p&gt;
&lt;pre&gt;
listnew = listold*1
&lt;/pre&gt;
&lt;p&gt;这里举点其他方法的例子：&lt;/p&gt;
&lt;pre&gt;
lista = [0, 1, 2, 3, 4]
print(&quot;a %s %s&quot; % (lista, id(lista)))

lista_ = lista					#实际没有复制
print(&quot;a_ %s %s&quot; % (lista_, id(lista_)))

'''
以下是复制
'''

listb = lista*1
print(&quot;b %s %s&quot; % (listb, id(listb)))

listc=[]
for i in lista:
    listc.append(i)				#append方法
print(&quot;c %s %s&quot; % (listc, id(listc)))

listd=[]
listd=lista[:]					#slice
print(&quot;d %s %s&quot; % (listd, id(listd)))

import copy
liste = copy.copy(lista)
print(&quot;e %s %s&quot; % (liste, id(liste)))

listf = [i for i in lista]			#列表生成式
print(&quot;f %s %s&quot; % (listf, id(listf)))


========================================
a [0, 1, 2, 3, 4] 40817648
a_ [0, 1, 2, 3, 4] 40817648
b [0, 1, 2, 3, 4] 40735088
c [0, 1, 2, 3, 4] 40817568
d [0, 1, 2, 3, 4] 40818648
e [0, 1, 2, 3, 4] 40818008
f [0, 1, 2, 3, 4] 40819608
&lt;/pre&gt;

&lt;p&gt;此外，如果list中带有list，list的拷贝就涉及了深拷贝和浅拷贝的知识点。不过这次先不考虑这个。还没到需要写list中带list的代码。用到了再学吧。&lt;/p&gt;
</description>
				
				<pubDate>Tue, 27 Feb 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/python-copy-list</link>
				<guid isPermaLink="true">http://localhost:4000/python-copy-list</guid>
			</item>
			
		
			
			<item>
				<title>pass</title>
				
					<description>&lt;p&gt;;&lt;/p&gt;
</description>
				
				<pubDate>Sat, 01 Jan 2011 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/test1-test2-test3</link>
				<guid isPermaLink="true">http://localhost:4000/test1-test2-test3</guid>
			</item>
			
		
	</channel>
</rss>

