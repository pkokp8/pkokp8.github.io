<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>“pkokp8's Blog” - Articles</title>
		<description>在这个世界多搬点砖，如果能造一块那就太好了</description>
		<link>http://localhost:4000</link>
		<atom:link href="http://localhost:4000/feed.articles.xml" rel="self" type="application/rss+xml" />
		
			
			<item>
				<title>颜色渐变</title>
				
					<description>&lt;p&gt;
  打开了windows的cmd--mspaint工具。想选用一种颜色，点到了编辑颜色的地方。发现这颜色渐变很神奇，横向纵向的颜色都是变化的。
&lt;/p&gt;
&lt;p&gt;
  于是决定写一份代码来实现这个颜色渐变的功能。一开始很sb的认为rgb的渐变不是很简单嘛，rgb888的最大色是0xffffff，最小色是0x0。(0xffffff-0x0)/(w*h)得到每个像素点的变化step，然后跟随像素点的座标不断加step。
&lt;/p&gt;
&lt;p&gt;
  仔细一想，这特么不是sb是什么。渐变是两种分量颜色不变，一种颜色分量慢慢变化。前面的那种算法画出来的图像简直一坨翔，惨不忍睹（其实看多了也还好？）。
&lt;/p&gt;
&lt;p&gt;
  幸好windows的画图工具给了颜色编辑时的每个点的rgb值，观察规律。最后用c语言，生成了一副rgb裸数据的图像。图像可以用7yuv查看。    
  话不多说，上代码。
&lt;/p&gt;

&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

#define WIDTH 1920
#define HEIGHT 1080
unsigned char dstrgb24[WIDTH*HEIGHT*3] = {0};


typedef enum _CHANG{
    ADDGERRN 	= 1,
    MINUSRED 	= 2,
    ADDBLUE 	= 3,
    MINUSGREEN 	= 4,
    ADDRED 		= 5,
    MINUSBLUE 	= 6,
    BUTT
}CHANGE;

int gwidth = WIDTH;
int gheight = HEIGHT;

#define abs(x) ((x)&amp;lt;0?(-1*(x)):(x))
int main()
{
    int pixel = 0;
    int x = 0;
    int y = 0;
    int startr, startg, startb;
    int endr, endg, endb;
    CHANGE flag = BUTT;
    for(y = 0; y &amp;lt; gheight; y++)
    {
        int r,g,b;
        int cnt = 0;
        startr = (-127) * y / gheight + 255;		//生成纵向最左侧的颜色
        startg = y * 127 / gheight;
        startb = y * 127 / gheight;
        endr = 255 - startr;						//这里取名有点误解，并不是右侧的end值，而是与start组成了颜色变化的范围
        endg = 255 - startg;
        endb = 255 - startg;

        r = startr;
        g = startg;
        b = startb;
        flag = ADDGERRN;
        for(x = 0; x &amp;lt; gwidth; x++)
        {
            double stepw = abs((endr - startr)) / (gwidth * 1.0);	//r,g,b的步长是一样的，用r计算就行了
            if(flag == ADDGERRN)					//观察画图工具的变化规律，最左侧是个定值，然后rgb分别变化，增加到最大值或减少到最大值后，进行下一个分量的变化。总共6种变化
            {
                g = startg + (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(g &amp;gt;= endg)
                {
                    cnt = 0;
                    g = endg;
                    flag++;
                }
            }
            else if(flag == MINUSRED)
            {
                r = startr - (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(r &amp;lt;= endr)
                {
                    cnt = 0;
                    r = endr;
                    flag++;
                }
            }
            else if(flag == ADDBLUE)
            {
                b = startb + (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(b &amp;gt;= endb)
                {
                    cnt = 0;
                    b = endb;
                    flag++;
                }
            }
            else if(flag == MINUSGREEN)
            {
                g = endg - (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(g &amp;lt;= startg)
                {
                    cnt = 0;
                    g = startg;
                    flag++;
                }
            }
            else if(flag == ADDRED)
            {
                r = endr + (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(r &amp;gt;= startr)
                {
                    cnt = 0;
                    r = startr;
                    flag++;
                }
            }
            else if(flag == MINUSBLUE)
            {
                b = endb - (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(b &amp;lt;= startb)
                {
                    cnt = 0;
                    b = startb;
                    flag++;
                }
            }
            else
            {
                //printf(&quot;???\n&quot;);
            }

            dstrgb24[pixel++] = r;
            dstrgb24[pixel++] = g;
            dstrgb24[pixel++] = b;
        }
    }
    FILE *fp = fopen(&quot;color.rgb&quot;, &quot;w+&quot;);
    if(fp != NULL)
    {
        fwrite(dstrgb24, gwidth * gheight * 3, 1, fp);
        fclose(fp);
    }
    printf(&quot;%d\n&quot;, pixel);
    return 0;

}

&lt;/pre&gt;

&lt;pre&gt;
[root@sf_share]# gcc color.c 
[root@sf_share]# ./a.out 
6220800
[root@sf_share]# ls color.rgb 
color.rgb

&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/images/color.png&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;
</description>
				
				<pubDate>Thu, 08 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98-c</link>
				<guid isPermaLink="true">http://localhost:4000/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98-c</guid>
			</item>
			
		
			
			<item>
				<title>libjpeg不完全解</title>
				
					<description>&lt;p&gt;先放一张图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libjpegmaterial/CactiIslaPescado_ZH-CN11317505000_1920x1080_orig.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;jpeg有非常多格式，后面会拿上图作示例。这是一张jfif格式的jpeg图像。&lt;/p&gt;

&lt;p&gt;这张图的格式是这样的：&lt;/p&gt;

&lt;pre&gt;
SOI				(0xFFD8)
APP0			(0xFFE0)
DQT				(0xFFDB)
DQT				(0xFFDB)
SOF0			(0xFFC0)
DHT				(0xFFC4)
DHT				(0xFFC4)
DHT				(0xFFC4)
DHT				(0xFFC4)
SOS				(0xFFDA)
实际图像的压缩数据
EOI				(0xFFD9)
&lt;/pre&gt;

&lt;p&gt;
然后放一段可以直接拿来用的libjpeg的sample代码。这段代码并没有经过仔细的优化，部分显示效果也并不是最佳。但作为解码的初解，应该够了吧。
&lt;/p&gt;
&lt;pre&gt;
int jpeg_to_yuv422(unsigned char *jpeg_buffer,int insize, unsigned char **yuv_buffer, int *yuvlen)
{
	int a, i;
	int width, height;
	int r, g, b;
	int c,m,y,k;
	struct jpeg_decompress_struct cinfo;
	struct my_error_mgr jerr;
	JSAMPARRAY buffer;
	int row_stride;
	unsigned char *curptr = NULL;
	unsigned char *rgb24_buffer = NULL;

	cinfo.err = jpeg_std_error(&amp;amp;jerr.pub);  
//  	jerr.pub.error_exit = my_error_exit;

	if(setjmp(jerr.setjmp_buffer))
	{
		printf(&quot;my err %d\n&quot;, insize);
		jpeg_destroy_decompress(&amp;amp;cinfo);

		return 1;
	}

	jpeg_create_decompress(&amp;amp;cinfo);
	jpeg_mem_src(&amp;amp;cinfo, jpeg_buffer, insize);
	(void) jpeg_read_header(&amp;amp;cinfo, TRUE);

	//cinfo.out_color_space = JCS_YCbCr;
	//cinfo.raw_data_out = TRUE;

	
	(void) jpeg_start_decompress(&amp;amp;cinfo);

	int alignwidth = 0;
	if(cinfo.output_width % 16)
	alignwidth = cinfo.output_width / 16 * 16 + 16;
	else
	alignwidth = cinfo.output_width;

	row_stride = alignwidth * cinfo.output_components;
	width = alignwidth;
	height = cinfo.output_height;
	*yuvlen = width * height * 2;

	buffer = (*cinfo.mem-&amp;gt;alloc_sarray) ((j_common_ptr) &amp;amp;cinfo, JPOOL_IMAGE, row_stride, 1);

	rgb24_buffer = (unsigned char*)malloc(width * height * 3);
	memset(rgb24_buffer, 0, width * height * 3);
	printf(&quot;%d, color space %d\n&quot;, __LINE__, cinfo.out_color_space);

	if(cinfo.out_color_space == JCS_RGB)
	{
		curptr = rgb24_buffer;
		for(a = 0; a &amp;lt; height; a++)
		{
			(void) jpeg_read_scanlines(&amp;amp;cinfo, buffer, 1);

			for(i = 0; i &amp;lt; row_stride; i += 3)
			{
				r = (int)buffer[0][i];
				g = (int)buffer[0][i + 1];
				b = (int)buffer[0][i + 2];

				*curptr++ = r;
				*curptr++ = g;
				*curptr++ = b;
			}

		}
	}
	else if(cinfo.out_color_space == JCS_GRAYSCALE)
	{
		curptr = rgb24_buffer;
		for(a = 0; a &amp;lt; height; a++)
		{
			(void) jpeg_read_scanlines(&amp;amp;cinfo, buffer, 1);

			for(i = 0; i &amp;lt; row_stride; i += 1)
			{
				g = (int)buffer[0][i];

				*curptr++ = g;
				*curptr++ = g;
				*curptr++ = g;
			}

		}
	}
	else if(cinfo.out_color_space == JCS_CMYK)
	{
		curptr = rgb24_buffer;
		for(a = 0; a &amp;lt; height; a++)
		{
			(void) jpeg_read_scanlines(&amp;amp;cinfo, buffer, 1);

			for(i = 0; i &amp;lt; row_stride; i += 4)
			{
				c = (int)buffer[0][i];
				m = (int)buffer[0][i + 1];
				y = (int)buffer[0][i + 2];
				k = (int)buffer[0][i + 3];

				
				r = (k*c)/255;
				g = (k*m)/255;
				b = (k*y)/255; 
				 
				*curptr++ = r;
				*curptr++ = g;
				*curptr++ = b;
			}

		}
	}
	else
	{
		printf(&quot;jpg_to_yuv:unsupported jpeg color space %d, aborting.\n&quot;,  cinfo.out_color_space);
		return -1;
	}
	//(*cinfo.mem-&amp;gt;free_pool) ((j_common_ptr) &amp;amp;cinfo, JPOOL_IMAGE);

	/* rbgb24 to yuv */
	{
		*yuv_buffer = (unsigned char*)malloc(width * height * 2);
		RGB2YUV422(rgb24_buffer, *yuv_buffer, height * width);
	}
	(void) jpeg_finish_decompress(&amp;amp;cinfo);

	jpeg_destroy_decompress(&amp;amp;cinfo);

	if(jerr.pub.num_warnings)
	{
		printf(&quot;jpg_to_yuv: jpeg lib warnings=%ld occurred\n&quot;, jerr.pub.num_warnings);
		return -1;
	}

	return 0;
}

&lt;/pre&gt;

&lt;p&gt;然后开始讲解一下这段代码。&lt;/p&gt;
&lt;h1 id=&quot;jpeg_std_error&quot;&gt;jpeg_std_error&lt;/h1&gt;
&lt;p&gt;这是一个异常处理函数相关的注册。libjpeg所有的异常返回，默认都是直接调用exit退出。也就是说如果发生了错误，程序就直接挂了。这在本地测试、使用时没什么问题，出错了定位一下，然后接着用。但生产环境中动不动就可能程序退出，还没什么日志，这怎么行？libjpeg提供了一种方法，先覆盖默认的error_exit函数指针。&lt;br /&gt;
例如提供一个my_error_exit函数通过jpeg_std_error注册进libjpeg。&lt;br /&gt;
在my_error_exit以及解码接口中通过setjmp/longjmp实现函数间的跳转&lt;/p&gt;
</description>
				
				<pubDate>Mon, 05 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/libjpeg-decode-c</link>
				<guid isPermaLink="true">http://localhost:4000/libjpeg-decode-c</guid>
			</item>
			
		
			
			<item>
				<title>剑指offer学习</title>
				
					<description>&lt;p&gt;对于第一章面试相关的技巧，结合自身之前面试的几次经验，记录几个比较重要的：  &lt;/p&gt;
&lt;p&gt;1.电话。投递简历后一般HR都是电话联系。可以记录一些有用的信息，然后让HR发一个邮件给你。例如联系方式、何时何地面试，有什么需要准备的等等. &lt;/p&gt;
&lt;p&gt;2.准备问题。面试会有HR面，技术面，老大面等等。提前想好针对谁可以问什么问题，以及面试过程中记住对方说的可以针对性的问。切忌问错人。我组长之前面试一个人回来后和我说他还问加不加班，印象不好。虽然我对这一点不予置评，但可见还是需要准备好问题的. &lt;/p&gt;
&lt;p&gt;3.自我介绍。面试者可能之前都不知道有要面试你这个任务，所以会让你简述一下自己。此时对于技术面可以加入项目、学习工作经历。切忌说完全不懂的，因为可能技术面会深入的问一两个问题 &lt;/p&gt;
&lt;p&gt;4.书中讲介绍项目可以用“项目背景-完成任务-为了完成任务做了什么怎么做的-贡献”。此外还需要准备这个项目中遇到了什么大问题、怎么解决的、学到了什么。&lt;/p&gt;
&lt;p&gt;5.“精通”是个很傻缺的词汇。  &lt;/p&gt;
&lt;p&gt;6.必须准备的答案：自我介绍、项目介绍、为什么跳槽。时刻注意解决问题要有清晰的思路。&lt;/p&gt;

&lt;p&gt;
  第二章开始就是一些基本知识了。这里记录一下自己思考、参考后写出的面试题C语言的答案
&lt;/p&gt;
&lt;pre&gt;
//面试题1、2不适合C语言答题。因此从3开始
//第三题的二位数组是行从小到大排序，列从小到大排序。
//从第一行的最后一列开始匹配，当前值大于查找值，可以排除当前列。因此列自减
//当前值小于查找值，可以排除当前行。因此行自增
//如果相等，则找到了。
//别忘了对边界条件进行判定
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

int arry[5][5] =
{
    {1,3,4,7,8},
    {2,5,6,9,11},
    {10,90,93,101,231},
    {25,57,59,99,103},
    {60,63,89,333,777}
};


int find(int str[5][5], int rows, int columns, int number)
{
    int r = 0;                      //行
    int c = 0;                      //列
    if(str == NULL &amp;amp;&amp;amp; rows &amp;gt; 0 &amp;amp;&amp;amp; columns &amp;gt; 0)
        return -1;

    r = 0;                          //行从0开始
    c = columns - 1;                //列从最后一列开始
    while(r&amp;lt;rows &amp;amp;&amp;amp; c &amp;gt;= 0)
    {
        if(str[r][c] == number)
            return 1;
        else if(str[r][c] &amp;lt; number)
        {
            r++;
        }
        else if(str[r][c] &amp;gt; number)
        {
            c--;
        }
    }
    return 0;
}

int main()
{
    int ret = find(arry, 5, 5, 6);
    printf(&quot;%d\n&quot;, ret);
    return 0;
}
&lt;/pre&gt;

&lt;pre&gt;
//第四题是查找替换空格。把整个字符串的空格替换成%20
//算法有两种。
//1.遇到一个空格就把后面的全部往后推3个。然后加入%20
//2.先扫描一遍有多少空格。然后结果字符串长度是本身长度+空格数*2。从后往前，遇到空格就在最后加'0','2','%'.普通字符直接复制到最后
//1简单。但建议用2，2需要两个指针，指向原字符串的最后，以及结果字符串的最后。然后往前遍历
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

char string[1000] = &quot;dsaf fdsfj ewq ck;lskffds sf s  sdfs sdf   fsdf   &quot;;

int replaceblank(char *str)
{
    unsigned int u32blankcnt = 0;
    int i = 0;
    for(i = 0; i &amp;lt; strlen(str) + 1; i++ )
    {
        if(str[i] == ' ')
            u32blankcnt++;
    }
    unsigned int u32strlen = strlen(str);
    unsigned int u32retlen = u32strlen + u32blankcnt*2;
    char *pcurstr = &amp;amp;(str[0]);
    char *pretstr = &amp;amp;(str[0]);
    int j = 0;
    for(i = u32strlen, j = u32retlen; i &amp;gt;=0; i--)
    {
        if(pcurstr[i] != ' ')
        {
            pretstr[j--] = pcurstr[i];

        }
        else
        {
            pretstr[j--] = '0';
            pretstr[j--] = '2';
            pretstr[j--] = '%';
        }
    }
}


int main()
{
    replaceblank(string);
    printf(&quot;%s\n&quot;, string);
    return 0;
}

&lt;/pre&gt;

&lt;p&gt;暂时看到这里。后续继续更新&lt;/p&gt;
</description>
				
				<pubDate>Thu, 01 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/%E5%89%91%E6%8C%87offer-linux-c</link>
				<guid isPermaLink="true">http://localhost:4000/%E5%89%91%E6%8C%87offer-linux-c</guid>
			</item>
			
		
			
			<item>
				<title>git的简单操作</title>
				
					<description>&lt;p&gt;
  记录一下git的使用。系统是ubuntu16.04. 安装好git环境  
  首先在github上右上角点一下+，然后New repository。  
  也可以本地创建好后push上去，不过这样也挺方便的。初学者嘛
&lt;/p&gt;

&lt;p&gt;
  然后是clone一个master，例如刚才创建的pkokp8.github.io.git分支
&lt;/p&gt;
&lt;pre&gt;
# git clone https://github.com/pkokp8/pkokp8.github.io.git
&lt;/pre&gt;

&lt;p&gt;接着就可以修改、提交文件&lt;/p&gt;
&lt;pre&gt;
# echo &quot;# test info&quot; &amp;gt;&amp;gt; README.md           #新建README.md
# git add .                                 #本地仓库新增这个文件
# git commit -m &quot;commit the readme&quot;         #提交到本地，日志为-m后面&quot;&quot;内的字符串。万一commit错误，可以不进行下一步，直接使用reset来回退代码，这样远端就不会有这次commit的记录
# git push -u origin master                 #push到远程主线。
&lt;/pre&gt;

&lt;p&gt;
  此时可能因为没有用户名和密码，会提示错误。可以配置后再执行上述命令
&lt;/p&gt;

&lt;pre&gt;
# git config --global user.name &quot;pkokp8&quot;
# git config --global user.email &quot;xxx@xx.com&quot;
&lt;/pre&gt;

&lt;p&gt;
  查看本地的提交记录，简单的可以使用。配合reset可以回退版本。注意-hard会把本地修改覆盖掉。  
  类似svn的svn revert ./ -R;svn up -r xxx
&lt;/p&gt;
&lt;pre&gt;
# git log
commit af17a9f424c5da5b4b06f90e69eb069f89124e40
Author: pkokp8 &amp;lt;xxx@xx.com&amp;gt;
Date:   Thu Mar 1 00:23:55 2018 +0800

    modify readme

# git reset -hard af17a9f424c5da5b4b06f90e69eb069f89124e40 
&lt;/pre&gt;

&lt;p&gt;
  接着就可以创建分支了：
&lt;/p&gt;
&lt;pre&gt;
# git branch firstversion                   #创建名为firstversion的分支
# git checkout firstversion                 #切换到这个分支
# git push -u origin firstversion           #把这个分支push到远端
# git checkout master                       #切换回主线
# git branch                                #查看当前处于哪条分支（看*），以及存在哪些分支
  firstversion
* master
# git diff                                  #查看本地与本地仓库之间的差异
&lt;/pre&gt;

&lt;p&gt;
  暂时就用到这么多。我感觉我还是要学习一个
&lt;/p&gt;
</description>
				
				<pubDate>Thu, 01 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/git-simple-use</link>
				<guid isPermaLink="true">http://localhost:4000/git-simple-use</guid>
			</item>
			
		
			
			<item>
				<title>复制一个list</title>
				
					<description>&lt;p&gt;初学python，爬图片的时候想复制一个list。一开始以为可以直接用这种方式复制list：
&lt;/p&gt;

&lt;pre&gt;
lista=[xxx, yyy, zzz]
listb=lista
&lt;/pre&gt;

&lt;p&gt;后来发现修改listb后lista的值也被修改了。原因是实际上listb就是lista。&lt;/p&gt;
&lt;p&gt;可以尝试用id函数打印出两个list的内存地址:&lt;/p&gt;
&lt;pre&gt;
lista = [0, 1, 2, 3, 4]
print(&quot;%s %s&quot; % (lista, id(lista)))

listb = lista
print(&quot;%s %s&quot; % (listb, id(listb)))

=============================
[0, 1, 2, 3, 4] 8246256
[0, 1, 2, 3, 4] 8246256

&lt;/pre&gt;

&lt;p&gt;
看得出，id相同。说明了两个list其实是同一个引用，这肯定不行。目的是为了新建一个list，同时修改新建的list不影响之前的list    
&lt;/p&gt;
&lt;p&gt;
有一种办法很粗暴：for循环遍历旧的list，新建一个空list，然后通过append方法把每一个元素添加进新的list。于是代码就是：
&lt;/p&gt;
&lt;pre&gt;
listnew=[]
for i in listold:
    listnew.append(i)
&lt;/pre&gt;
&lt;p&gt;
这个方法类似于在c语言中写出这样的代码:
&lt;/p&gt;
&lt;pre&gt;
char old[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
char new[10];
int i = 0;
for(i = 0;i &amp;lt; sizeof(old)/sizeof(char); i++)
{
	new[i] = old[i];
}
&lt;/pre&gt;
&lt;p&gt;你退群吧。除非要对数组每个成员进行处理，否则遍历有什么意义，memcpy()不行吗？&lt;/p&gt;
&lt;p&gt;而对于python来说，复制一个list有一些巧妙方法，例如：&lt;/p&gt;
&lt;pre&gt;
listnew = listold*1
&lt;/pre&gt;
&lt;p&gt;这里举点其他方法的例子：&lt;/p&gt;
&lt;pre&gt;
lista = [0, 1, 2, 3, 4]
print(&quot;a %s %s&quot; % (lista, id(lista)))

lista_ = lista					#实际没有复制
print(&quot;a_ %s %s&quot; % (lista_, id(lista_)))

'''
以下是复制
'''

listb = lista*1
print(&quot;b %s %s&quot; % (listb, id(listb)))

listc=[]
for i in lista:
    listc.append(i)				#append方法
print(&quot;c %s %s&quot; % (listc, id(listc)))

listd=[]
listd=lista[:]					#slice
print(&quot;d %s %s&quot; % (listd, id(listd)))

import copy
liste = copy.copy(lista)
print(&quot;e %s %s&quot; % (liste, id(liste)))

listf = [i for i in lista]			#列表生成式
print(&quot;f %s %s&quot; % (listf, id(listf)))


========================================
a [0, 1, 2, 3, 4] 40817648
a_ [0, 1, 2, 3, 4] 40817648
b [0, 1, 2, 3, 4] 40735088
c [0, 1, 2, 3, 4] 40817568
d [0, 1, 2, 3, 4] 40818648
e [0, 1, 2, 3, 4] 40818008
f [0, 1, 2, 3, 4] 40819608
&lt;/pre&gt;

&lt;p&gt;此外，如果list中带有list，list的拷贝就涉及了深拷贝和浅拷贝的知识点。不过这次先不考虑这个。还没到需要写list中带list的代码。用到了再学吧。&lt;/p&gt;
</description>
				
				<pubDate>Tue, 27 Feb 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/python-copy-list</link>
				<guid isPermaLink="true">http://localhost:4000/python-copy-list</guid>
			</item>
			
		
			
			<item>
				<title>pass</title>
				
					<description>&lt;p&gt;;&lt;/p&gt;
</description>
				
				<pubDate>Sat, 01 Jan 2011 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/test1-test2-test3</link>
				<guid isPermaLink="true">http://localhost:4000/test1-test2-test3</guid>
			</item>
			
		
			
			<item>
				<title>pass</title>
				
					<description>&lt;p&gt;;&lt;/p&gt;
</description>
				
				<pubDate>Sat, 01 Jan 2011 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/test1-test2-test3</link>
				<guid isPermaLink="true">http://localhost:4000/test1-test2-test3</guid>
			</item>
			
		
	</channel>
</rss>

