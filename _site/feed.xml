<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
	<channel>
		<title>“pkokp8's Blog” - Articles</title>
		<description>在这个世界多搬点砖，如果能造一块那就太好了</description>
		<link>http://localhost:4000</link>
		<atom:link href="http://localhost:4000/feed.articles.xml" rel="self" type="application/rss+xml" />
		
			
			<item>
				<title>两种无损变长编码</title>
				
					<description>&lt;p&gt;最近看了下哥伦布编码，在此记录一下。&lt;br /&gt;
正好上一次写了libjpeg的解码。jpeg的编解码中涉及了一种编解码算法，叫做哈夫曼编码。这里也顺便讲一下。&lt;/p&gt;

&lt;h2 id=&quot;一阶无符号指数哥伦布编码&quot;&gt;一阶无符号指数哥伦布编码&lt;/h2&gt;
&lt;p&gt;264/265的编解码中，一些码流信息是通过哥伦布编码的方式编进码流的。&lt;br /&gt;
例如264的条带头解析中，表示IDR帧的序号是idr_pic_id，这个参数在264码流中是通过ue编码的，即无符号(u)指数(e)哥伦布编码&lt;br /&gt;
哥伦布编码有很多种变种，此处只讲一下一阶无符号指数哥伦布编解码。&lt;/p&gt;

&lt;h1 id=&quot;编码&quot;&gt;编码&lt;/h1&gt;
&lt;p&gt;例如对20进行ue编码&lt;br /&gt;
1.将X转换为二进制。20即10100。&lt;br /&gt;
2.对该值进行加1计算。得到10101&lt;br /&gt;
3.得到该二进制串的长度M。此处M=5&lt;br /&gt;
4.在码流前补充M-1个0。此处得到000010101&lt;/p&gt;

&lt;h1 id=&quot;解码&quot;&gt;解码&lt;/h1&gt;
&lt;p&gt;接下来对上述编码完的数据进行解码。&lt;br /&gt;
1.首先读取码流的连续N个0，直到遇到1为止。000010101有连续N=4个前导0
2.然后读取N+1位数据X。此处为10101
3.对X进行-1计算即得到了原始的码字。b(10101) - 1 = b(10100) = d(20)&lt;/p&gt;

&lt;p&gt;可以看出，这是一种无损编解码方式。编解码过程中没有精度的丢失。&lt;/p&gt;

&lt;h1 id=&quot;ffmpeg的哥伦布解码操作&quot;&gt;ffmpeg的哥伦布解码操作&lt;/h1&gt;
&lt;p&gt;先贴代码&lt;br /&gt;
todo：注释&lt;/p&gt;
&lt;pre&gt;
/* libavcodec/golomb.h */
static inline int get_ue_golomb(GetBitContext *gb)
{
    unsigned int buf;

    OPEN_READER(re, gb);
    UPDATE_CACHE(re, gb);
    buf = GET_CACHE(re, gb);

    if (buf &amp;gt;= (1 &amp;lt;&amp;lt; 27)) {
        buf &amp;gt;&amp;gt;= 32 - 9;
        LAST_SKIP_BITS(re, gb, ff_golomb_vlc_len[buf]);
        CLOSE_READER(re, gb);

        return ff_ue_golomb_vlc_code[buf];
    } else {
        int log = 2 * av_log2(buf) - 31;
        LAST_SKIP_BITS(re, gb, 32 - log);
        CLOSE_READER(re, gb);
        if (CONFIG_FTRAPV &amp;amp;&amp;amp; log &amp;lt; 0) {
            av_log(NULL, AV_LOG_ERROR, &quot;Invalid UE golomb code\n&quot;);
            return AVERROR_INVALIDDATA;
        }
        buf &amp;gt;&amp;gt;= log;
        buf--;

        return buf;
    }
}
&lt;/pre&gt;

&lt;h1 id=&quot;哥伦布编码好处&quot;&gt;哥伦布编码好处&lt;/h1&gt;
&lt;p&gt;与定长编码不同，哥伦布编码是一种变长编码。&lt;br /&gt;
对于定长编码，举个例子，需要编码一个数字0和一个数字4&lt;br /&gt;
假设数据处于0-255之间，那么可以使用unsigned char来存储这段数据&lt;br /&gt;
0就会被编码成0000 0000&lt;br /&gt;
4就会被编码成0000 0100&lt;br /&gt;
于是生成了一段二进制码流0000 0000 0000 0100&lt;br /&gt;
其中有效的信息是0和100&lt;/p&gt;

&lt;p&gt;那么对于哥伦布编码，会产生这样的码流：&lt;br /&gt;
0会被编码成1&lt;br /&gt;
4会被编码成00101&lt;br /&gt;
于是得到了一段码流100101&lt;/p&gt;

&lt;p&gt;可见，码流长度被大大的缩减了。&lt;br /&gt;
本来码流的长度是16个二进制位，现在只有6个。&lt;/p&gt;

&lt;p&gt;于是能得到一种结论：以后都用哥伦布编码不就行了？&lt;br /&gt;
不行！&lt;br /&gt;
哥伦布编码实际有效信息是除了前导0的部分，前导0是无效信息。而数字越小的部分，前导0越少，数字越大的部分，前导0越多。&lt;br /&gt;
假设一个0和一个0xffff ffff需要被编码，用u32来表示就是32个0和32个1。总长度是64。&lt;br /&gt;
但是用哥伦布编码就是1个1和32个0和1个1和32个0。结果总长度是66。&lt;br /&gt;
看得出此时反而使用定长编码较好，编解码方式也简单。&lt;/p&gt;

&lt;h1 id=&quot;总结&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;那么什么时候可以用哥伦布编码呢？&lt;br /&gt;
一开始我认为，当需要被编码的数据【大概率】处于较小的值时，可以用哥伦布编码。&lt;br /&gt;
后来看到H264手册中存在类似这样的值：bit_depth_luma_minus8。这个值也是用哥伦布编码的。看到这个位的名字里有个minus8，虽然不知道这个值什么意思，但看名字应该是某个值-8后的值被编码了。&lt;br /&gt;
于是我认为，只要被编码的数据【大概率】分布于【某个区间】时，就可以用哥伦布编码。&lt;/p&gt;

&lt;p&gt;这是因为，假如数据99.99%的概率存在于0xffff fff0 - 0xffff ffff之间，剩下的数据是0 - 0xffff ffef平均分布的。只要对所有待编码的数据减去0xffff fff0操作。那么待编码的数据就变成了99.99%的概率分布于0-f。约定解码后加上0xffff fff0即可。&lt;/p&gt;

&lt;h2 id=&quot;哈夫曼编码&quot;&gt;哈夫曼编码&lt;/h2&gt;

&lt;h1 id=&quot;编码-1&quot;&gt;编码&lt;/h1&gt;
&lt;p&gt;假设有一段码流，为ABABDAABCD&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;统计各个码字出现的概率，并将码字按出现概率从大到小排序&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/images/huffman/huffman3.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;选取出现概率最小的两个码字（DC），构建一个根节点。左子节点的值左边那个码字（D），右子节点是右边那个码字（C）。根节点的值(假设为E)为DC的值相加。E替换DC的位置。
&lt;img src=&quot;/images/huffman/huffman1.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;继续上述步骤，直到生成一个根节点的值为所有值相加(A+B+C+D)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将所有左节点标记为0，右节点标记为1
&lt;img src=&quot;/images/huffman/huffman2.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;于是可以开始编码
A的编码为0&lt;br /&gt;
B的编码为10&lt;br /&gt;
C的编码为111&lt;br /&gt;
D的编码为110&lt;br /&gt;
ABABDAABCD的编码就是&lt;br /&gt;
0100101100010111110&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;解码-1&quot;&gt;解码&lt;/h1&gt;
&lt;p&gt;解码首先需要重建这颗haffman树。例如jpeg的DHT字段就含有重构huffman表的信息&lt;br /&gt;
然后去读取编码后的码流0100101100010111110&lt;br /&gt;
0是A，10是B，0是A，10是B，110是D，0是A，0是A，10是B，111是C，110是D&lt;br /&gt;
于是得到ABABDAABCD的原始码流&lt;/p&gt;

&lt;h1 id=&quot;总结-1&quot;&gt;总结&lt;/h1&gt;
&lt;p&gt;haffman的思想是在haffman树上方的节点，其码字在整段码流中出现的概率高，编码后的长度短。下方的出现概率低，编码后的长度长。&lt;/p&gt;

&lt;h2 id=&quot;两种编码方式的总结&quot;&gt;两种编码方式的总结&lt;/h2&gt;
&lt;p&gt;哈夫曼编码与哥伦布编码的思想比较接近，通过特定的规则，将出现概率大的数字编码成较短的码流。以达到减少数据量的目的。&lt;/p&gt;

</description>
				
				<pubDate>Wed, 14 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/%E4%B8%A4%E7%A7%8D%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81</link>
				<guid isPermaLink="true">http://localhost:4000/%E4%B8%A4%E7%A7%8D%E5%8F%98%E9%95%BF%E7%BC%96%E7%A0%81</guid>
			</item>
			
		
			
			<item>
				<title>颜色渐变</title>
				
					<description>&lt;p&gt;
  打开了windows的cmd--mspaint工具。想选用一种颜色，点到了编辑颜色的地方。发现这颜色渐变很神奇，横向纵向的颜色都是变化的。
&lt;/p&gt;
&lt;p&gt;
  于是决定写一份代码来实现这个颜色渐变的功能。一开始很sb的认为rgb的渐变不是很简单嘛，rgb888的最大色是0xffffff，最小色是0x0。(0xffffff-0x0)/(w*h)得到每个像素点的变化step，然后跟随像素点的座标不断加step。
&lt;/p&gt;
&lt;p&gt;
  仔细一想，这特么不是sb是什么。渐变是两种分量颜色不变，一种颜色分量慢慢变化。前面的那种算法画出来的图像简直一坨翔，惨不忍睹（其实看多了也还好？）。
&lt;/p&gt;
&lt;p&gt;
  幸好windows的画图工具给了颜色编辑时的每个点的rgb值，观察规律。最后用c语言，生成了一副rgb裸数据的图像。图像可以用7yuv查看。    
  话不多说，上代码。
&lt;/p&gt;

&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;

#define WIDTH 1920
#define HEIGHT 1080
unsigned char dstrgb24[WIDTH*HEIGHT*3] = {0};


typedef enum _CHANG{
    ADDGERRN 	= 1,
    MINUSRED 	= 2,
    ADDBLUE 	= 3,
    MINUSGREEN 	= 4,
    ADDRED 		= 5,
    MINUSBLUE 	= 6,
    BUTT
}CHANGE;

int gwidth = WIDTH;
int gheight = HEIGHT;

#define abs(x) ((x)&amp;lt;0?(-1*(x)):(x))
int main()
{
    int pixel = 0;
    int x = 0;
    int y = 0;
    int startr, startg, startb;
    int endr, endg, endb;
    CHANGE flag = BUTT;
    for(y = 0; y &amp;lt; gheight; y++)
    {
        int r,g,b;
        int cnt = 0;
        startr = (-127) * y / gheight + 255;		//生成纵向最左侧的颜色
        startg = y * 127 / gheight;
        startb = y * 127 / gheight;
        endr = 255 - startr;						//这里取名有点误解，并不是右侧的end值，而是与start组成了颜色变化的范围
        endg = 255 - startg;
        endb = 255 - startg;

        r = startr;
        g = startg;
        b = startb;
        flag = ADDGERRN;
        for(x = 0; x &amp;lt; gwidth; x++)
        {
            double stepw = abs((endr - startr)) / (gwidth * 1.0);	//r,g,b的步长是一样的，用r计算就行了
            if(flag == ADDGERRN)					//观察画图工具的变化规律，最左侧是个定值，然后rgb分别变化，增加到最大值或减少到最大值后，进行下一个分量的变化。总共6种变化
            {
                g = startg + (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(g &amp;gt;= endg)
                {
                    cnt = 0;
                    g = endg;
                    flag++;
                }
            }
            else if(flag == MINUSRED)
            {
                r = startr - (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(r &amp;lt;= endr)
                {
                    cnt = 0;
                    r = endr;
                    flag++;
                }
            }
            else if(flag == ADDBLUE)
            {
                b = startb + (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(b &amp;gt;= endb)
                {
                    cnt = 0;
                    b = endb;
                    flag++;
                }
            }
            else if(flag == MINUSGREEN)
            {
                g = endg - (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(g &amp;lt;= startg)
                {
                    cnt = 0;
                    g = startg;
                    flag++;
                }
            }
            else if(flag == ADDRED)
            {
                r = endr + (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(r &amp;gt;= startr)
                {
                    cnt = 0;
                    r = startr;
                    flag++;
                }
            }
            else if(flag == MINUSBLUE)
            {
                b = endb - (int)(stepw * (BUTT - 1) * cnt);
                cnt++;
                if(b &amp;lt;= startb)
                {
                    cnt = 0;
                    b = startb;
                    flag++;
                }
            }
            else
            {
                //printf(&quot;???\n&quot;);
            }

            dstrgb24[pixel++] = r;
            dstrgb24[pixel++] = g;
            dstrgb24[pixel++] = b;
        }
    }
    FILE *fp = fopen(&quot;color.rgb&quot;, &quot;w+&quot;);
    if(fp != NULL)
    {
        fwrite(dstrgb24, gwidth * gheight * 3, 1, fp);
        fclose(fp);
    }
    printf(&quot;%d\n&quot;, pixel);
    return 0;

}

&lt;/pre&gt;

&lt;pre&gt;
[root@sf_share]# gcc color.c 
[root@sf_share]# ./a.out 
6220800
[root@sf_share]# ls color.rgb 
color.rgb

&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;/images/color.png&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;
</description>
				
				<pubDate>Thu, 08 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98-c</link>
				<guid isPermaLink="true">http://localhost:4000/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86-%E9%A2%9C%E8%89%B2%E6%B8%90%E5%8F%98-c</guid>
			</item>
			
		
			
			<item>
				<title>libjpeg解码篇</title>
				
					<description>&lt;p&gt;既然是jpeg解码，那就先放一张图。图是从bing首页上爬下来的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/libjpegmaterial/CactiIslaPescado_ZH-CN11317505000_1920x1080_orig.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;jpeg有非常多格式，后面的demo会拿上图作示例，不保证所有图片都能解码。&lt;br /&gt;
这是一张jfif格式的jpeg图像。&lt;/p&gt;

&lt;p&gt;这张图的格式是这样的：&lt;/p&gt;

&lt;pre&gt;
SOI				(0xFFD8)
APP0			(0xFFE0)
DQT				(0xFFDB)
DQT				(0xFFDB)
SOF0			(0xFFC0)
DHT				(0xFFC4)
DHT				(0xFFC4)
DHT				(0xFFC4)
DHT				(0xFFC4)
SOS				(0xFFDA)
实际图像的压缩数据
EOI				(0xFFD9)
&lt;/pre&gt;

&lt;p&gt;
然后话不多说，直接先放一段可以直接拿来用的libjpeg的sample代码。  
这段代码并没有经过仔细的优化，部分显示效果也并不是最佳。但作为初步认识libjpeg，应该够了吧。
&lt;/p&gt;
&lt;pre&gt;
int jpeg_to_yuv(unsigned char *jpeg_buffer,int insize, unsigned char **yuv_buffer, int *yuvlen)
{
	int a, i;
	int width, height;
	int r, g, b;
	int c,m,y,k;
	struct jpeg_decompress_struct cinfo;
	struct my_error_mgr jerr;
	JSAMPARRAY buffer;
	int row_stride;
	unsigned char *curptr = NULL;
	unsigned char *rgb24_buffer = NULL;

	cinfo.err = jpeg_std_error(&amp;amp;jerr.pub);  
//  	jerr.pub.error_exit = my_error_exit;

	if(setjmp(jerr.setjmp_buffer))
	{
		printf(&quot;my err %d\n&quot;, insize);
		jpeg_destroy_decompress(&amp;amp;cinfo);

		return 1;
	}

	jpeg_create_decompress(&amp;amp;cinfo);
	jpeg_mem_src(&amp;amp;cinfo, jpeg_buffer, insize);
	(void) jpeg_read_header(&amp;amp;cinfo, TRUE);

	//cinfo.out_color_space = JCS_YCbCr;
	//cinfo.raw_data_out = TRUE;

	
	(void) jpeg_start_decompress(&amp;amp;cinfo);

	int alignwidth = 0;
	if(cinfo.output_width % 16)
	alignwidth = cinfo.output_width / 16 * 16 + 16;
	else
	alignwidth = cinfo.output_width;

	row_stride = alignwidth * cinfo.output_components;
	width = alignwidth;
	height = cinfo.output_height;
	*yuvlen = width * height * 2;

	buffer = (*cinfo.mem-&amp;gt;alloc_sarray) ((j_common_ptr) &amp;amp;cinfo, JPOOL_IMAGE, row_stride, 1);

	rgb24_buffer = (unsigned char*)malloc(width * height * 3);
	memset(rgb24_buffer, 0, width * height * 3);
	printf(&quot;%d, color space %d\n&quot;, __LINE__, cinfo.out_color_space);

	if(cinfo.out_color_space == JCS_RGB)
	{
		curptr = rgb24_buffer;
		for(a = 0; a &amp;lt; height; a++)
		{
			(void) jpeg_read_scanlines(&amp;amp;cinfo, buffer, 1);

			for(i = 0; i &amp;lt; row_stride; i += 3)
			{
				r = (int)buffer[0][i];
				g = (int)buffer[0][i + 1];
				b = (int)buffer[0][i + 2];

				*curptr++ = r;
				*curptr++ = g;
				*curptr++ = b;
			}

		}
	}
	else if(cinfo.out_color_space == JCS_GRAYSCALE)
	{
		curptr = rgb24_buffer;
		for(a = 0; a &amp;lt; height; a++)
		{
			(void) jpeg_read_scanlines(&amp;amp;cinfo, buffer, 1);

			for(i = 0; i &amp;lt; row_stride; i += 1)
			{
				g = (int)buffer[0][i];

				*curptr++ = g;
				*curptr++ = g;
				*curptr++ = g;
			}

		}
	}
	else if(cinfo.out_color_space == JCS_CMYK)
	{
		curptr = rgb24_buffer;
		for(a = 0; a &amp;lt; height; a++)
		{
			(void) jpeg_read_scanlines(&amp;amp;cinfo, buffer, 1);

			for(i = 0; i &amp;lt; row_stride; i += 4)
			{
				c = (int)buffer[0][i];
				m = (int)buffer[0][i + 1];
				y = (int)buffer[0][i + 2];
				k = (int)buffer[0][i + 3];

				
				r = (k*c)/255;
				g = (k*m)/255;
				b = (k*y)/255; 
				 
				*curptr++ = r;
				*curptr++ = g;
				*curptr++ = b;
			}

		}
	}
	else
	{
		printf(&quot;jpg_to_yuv:unsupported jpeg color space %d, aborting.\n&quot;,  cinfo.out_color_space);
		return -1;
	}
	//(*cinfo.mem-&amp;gt;free_pool) ((j_common_ptr) &amp;amp;cinfo, JPOOL_IMAGE);

	/* rbgb24 to yuv */
	{
		*yuv_buffer = (unsigned char*)malloc(width * height * 2);
		RGB2YUV(rgb24_buffer, *yuv_buffer, height * width);
	}
	(void) jpeg_finish_decompress(&amp;amp;cinfo);

	jpeg_destroy_decompress(&amp;amp;cinfo);

	if(jerr.pub.num_warnings)
	{
		printf(&quot;jpg_to_yuv: jpeg lib warnings=%ld occurred\n&quot;, jerr.pub.num_warnings);
		return -1;
	}

	return 0;
}

&lt;/pre&gt;

&lt;p&gt;然后开始讲解一下这段代码。&lt;/p&gt;
&lt;h2 id=&quot;jpeg_std_error&quot;&gt;jpeg_std_error&lt;/h2&gt;

&lt;p&gt;这是一个异常处理函数相关的注册。libjpeg所有的异常返回，默认都是调用exit退出。也就是说如果发生了逻辑上的错误（流程、参数错误之类的），程序就直接就挂了，并且即使注册了信号处理函数都无法捕捉。&lt;br /&gt;
这在本地测试、使用时没什么问题，出错了定位一下，然后接着用。但生产环境中动不动就可能程序退出，还没什么日志，这怎么行？因此libjpeg也提供了一种方法，需要覆盖默认的error_exit函数指针。&lt;br /&gt;
例如提供一个my_error_exit函数通过jpeg_std_error注册进libjpeg。&lt;br /&gt;
在my_error_exit以及解码接口中通过setjmp/longjmp实现函数间的跳转。具体可以看一下example.c的实现。不难&lt;/p&gt;

&lt;h2 id=&quot;jpeg_create_decompress&quot;&gt;jpeg_create_decompress&lt;/h2&gt;
&lt;pre&gt;
/* jpeglib.h */
#define jpeg_create_decompress(cinfo) \
    jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, \
			  (size_t) sizeof(struct jpeg_decompress_struct))

&lt;/pre&gt;
&lt;p&gt;jpeg_create_decompress就是jpeg_CreateDecompress。函数实现在jdapimin.c中。&lt;br /&gt;
有一点需要提一下，源码文件前缀的命名，j是jpeg，c是compress，d是decompress。看解码相关的代码时，搜函数搜到的jc开头的文件里时一般可以忽略了。既不是c也不是d，但是j开头的，说明是公共文件。如果都不是，有可能是一个demo，也有可能是一些扩展功能，例如bmp函数相关的封装等。&lt;br /&gt;
进入这个函数内部一步步的看可以发现，这个create接口仅仅是向解码结构体j_decompress_ptr中注册一些函数指针，初始化一些数据结构，并且标记这个解码结构体的解码状态为DSTATE_START。解码状态是个一次解码中的全局标志位，可以通过解码结构体查询和设置。因为是单线程解码，没有锁的问题。&lt;/p&gt;
&lt;pre&gt;
/* Values of global_state field (jdapi.c has some dependencies on ordering!) */
#define CSTATE_START	100	/* after create_compress */
#define CSTATE_SCANNING	101	/* start_compress done, write_scanlines OK */
#define CSTATE_RAW_OK	102	/* start_compress done, write_raw_data OK */
#define CSTATE_WRCOEFS	103	/* jpeg_write_coefficients done */
#define DSTATE_START	200	/* after create_decompress */
#define DSTATE_INHEADER	201	/* reading header markers, no SOS yet */
#define DSTATE_READY	202	/* found SOS, ready for start_decompress */
#define DSTATE_PRELOAD	203	/* reading multiscan file in start_decompress*/
#define DSTATE_PRESCAN	204	/* performing dummy pass for 2-pass quant */
#define DSTATE_SCANNING	205	/* start_decompress done, read_scanlines OK */
#define DSTATE_RAW_OK	206	/* start_decompress done, read_raw_data OK */
#define DSTATE_BUFIMAGE	207	/* expecting jpeg_start_output */
#define DSTATE_BUFPOST	208	/* looking for SOS/EOI in jpeg_finish_output */
#define DSTATE_RDCOEFS	209	/* reading file in jpeg_read_coefficients */
#define DSTATE_STOPPING	210	/* looking for EOI in jpeg_finish_decompress */
&lt;/pre&gt;

&lt;h2 id=&quot;jpeg_mem_src&quot;&gt;jpeg_mem_src&lt;/h2&gt;
&lt;p&gt;jpeg_mem_src在libjpeg.so.62是不存在的。但在较新版本中存在这个接口。较新版本的libjpeg使用时遇到了一些问题，暂时没找到解决办法，因此就把新版本库中的这个接口移植了过来。移植方法很简单，新版本内搜一下这个函数，直接拿过来放在62版本同样的位置。编译一下，提示少定义函数了，就抄着新版本移植一下。提示少声明了，照着新版本声明一下。几分钟就搞定了。&lt;br /&gt;
这个接口的功能是将jpeg的内存数据送给解码结构体。入参除了解码结构体，还有一个buffer和一个size，显然buffer就是需要解码的jpegbuffer的指针，size就是长度。函数会把buffer和size注册给解码结构体内部的一个jpeg内存管理结构。此外就是注册一些内存管理的函数指针了。&lt;/p&gt;

&lt;h2 id=&quot;jpeg_read_header&quot;&gt;jpeg_read_header&lt;/h2&gt;
&lt;p&gt;看名字就可以知道，这个函数的功能是读取一下jpeg头。jpeg头中包含了很多解码需要的信息，例如huffman表，量化表，jpeg的长宽、位宽等等。&lt;br /&gt;
那么具体看一下，首先这个接口调用了jpeg_consume_input，接着根据返回值就返回了。联系函数名叫做readheader，那么jpeg_consume_input的返回值必定是JPEG_REACHED_SOS。否则如果是JPEG_REACHED_EOI（EOI，end of image），那干脆叫jpeg_decoder算了。&lt;/p&gt;
&lt;h1 id=&quot;jpeg_consume_input&quot;&gt;jpeg_consume_input&lt;/h1&gt;
&lt;pre&gt;
GLOBAL(int)
jpeg_consume_input (j_decompress_ptr cinfo)
{
  int retcode = JPEG_SUSPENDED;

  /* NB: every possible DSTATE value should be listed in this switch */
  switch (cinfo-&amp;gt;global_state) {
  case DSTATE_START:
    /* Start-of-datastream actions: reset appropriate modules */
    (*cinfo-&amp;gt;inputctl-&amp;gt;reset_input_controller) (cinfo);
    /* Initialize application's data source module */
    (*cinfo-&amp;gt;src-&amp;gt;init_source) (cinfo);
    cinfo-&amp;gt;global_state = DSTATE_INHEADER;
    /*FALLTHROUGH*/
  case DSTATE_INHEADER:
    retcode = (*cinfo-&amp;gt;inputctl-&amp;gt;consume_input) (cinfo);
    if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */
      /* Set up default parameters based on header data */
      default_decompress_parms(cinfo);
      /* Set global state: ready for start_decompress */
      cinfo-&amp;gt;global_state = DSTATE_READY;
    }
    break;
&lt;/pre&gt;
&lt;p&gt;里面就是个switch…case。首先解码状态在jpeg_create_decompress时被设为DSTATE_START，因此调用了reset_input_controller以及init_source，并标记解码状态为DSTATE_INHEADER。&lt;br /&gt;
接着调用consume_input，以及default_decompress_parms，并标记解码状态为DSTATE_READY。&lt;br /&gt;
reset_marker_reader看名字，叫做reset marker reader，外层函数叫做read header，显然就是用来重置解码结构体中marker相关的内容的。看进去也可以发现，没有实际的读取jpegbuffer。&lt;br /&gt;
init_source更简单，标记 ((my_src_ptr)cinfo-&amp;gt;src)-&amp;gt;start_of_file为true。意味着获取到了数据。那么显然主要操作在consume_input和default_decompress_parms中。&lt;br /&gt;
consume_input函数指针是jdinput.c–consume_markers函数。调用read_markers并返回JPEG_REACHED_SOS，接着调用initial_setup判断一下之前读出来的一些信息的合法性。&lt;/p&gt;
&lt;h1 id=&quot;read_markers&quot;&gt;read_markers&lt;/h1&gt;
&lt;p&gt;可以看到，这个函数就是个死循环。一开始unread_marker和saw_SOI都是0，先用first_marker读第一个标记M_SOI，并标记saw_SOI为TRUE，于是下一次就会调用next_marker，每次通过switch…case处理当前读到的标记下面的一段数据，直到读到M_SOS就会返回JPEG_REACHED_SOS。至于如何解析各个标记，可以去找一下jpeg的头的格式。网上资料还是比较详细的。&lt;/p&gt;
&lt;pre&gt;
	printf(&quot;unread_marker = %x\n&quot;, cinfo-&amp;gt;unread_marker);		//此处加一句打印
    /* At this point cinfo-&amp;gt;unread_marker contains the marker code and the
     * input point is just past the marker proper, but before any parameters.
     * A suspension will cause us to return with this state still true.
     */
    switch (cinfo-&amp;gt;unread_marker) {
&lt;/pre&gt;
&lt;p&gt;就可以看到文章最开始的那张图像会打印如下信息。&lt;/p&gt;
&lt;pre&gt;
unread_marker = d8
unread_marker = e0
unread_marker = db
unread_marker = db
unread_marker = c0
unread_marker = c4
unread_marker = c4
unread_marker = c4
unread_marker = c4
unread_marker = da
&lt;/pre&gt;
&lt;p&gt;例如根据jpeg的格式，一张jpeg的宽高可以从sof标记后面的数据得到：
&lt;img src=&quot;/images/libjpegmaterial/1.jpg&quot; alt=&quot;avatar&quot; /&gt;
1920=0x0780&lt;br /&gt;
1080=0x0438&lt;br /&gt;
当然并不是所有jpeg图像都有上述的各个标记。具体图像具体分析。&lt;br /&gt;
最终read_markers将返回值JPEG_REACHED_SOS返回到jpeg_consume_input中，会接着执行default_decompress_parms。&lt;br /&gt;
根据default_decompress_parms的注释，这段代码是一个猜测的经验值，并没有规定一定是这样。jpeg_color_space是输入的jpeg的色彩空间。out_color_space是输出的。
&lt;img src=&quot;/images/libjpegmaterial/2.jpg&quot; alt=&quot;avatar&quot; /&gt;
最上方的这张图的输入是JCS_YCbCr，输出在此处被设为了JCS_RGB。理论上如果需要实现解码成yuv，那么此处应该设置输出为JCS_YCbCr。这个后面再讲。(1)&lt;br /&gt;
最终设置一些默认解码参数，例如raw_data_out为false，dct_method为JDCT_DEFAULT，scale比例为1等等，之后函数就结束了。&lt;br /&gt;
最终jpeg_consume_input标记解码状态为DSTATE_READY，jpeg_read_header就正常的结束了。&lt;/p&gt;

&lt;h2 id=&quot;jpeg_start_decompress&quot;&gt;jpeg_start_decompress&lt;/h2&gt;
&lt;p&gt;调用jinit_master_decompress初始化master。这是个私有数据，可以暂不关心。并标记解码状态为DSTATE_PRELOAD。&lt;br /&gt;
progress这个函数指针是注册一个进度处理函数，可以显示进度。一般可以不注册，那么就忽略。&lt;br /&gt;
而has_multiple_scans标记位，看名字意思是jpeg图像中有多个扫描。上面这张图并没有这个特征。&lt;br /&gt;
接着调用output_pass_setup就可以返回了。&lt;/p&gt;
&lt;h1 id=&quot;output_pass_setup&quot;&gt;output_pass_setup&lt;/h1&gt;
&lt;p&gt;注意此处的解码状态依然是DSTATE_PRELOAD，因此会调用prepare_for_output_pass。is_dummy_pass在jinit_master_decompress时被初始化为false，因此下面其实是个不执行的循环，意思是prepare_for_output_pass执行完就基本返回了。&lt;br /&gt;
prepare_for_output_pass中首先和上面说的一样，is_dummy_pass是false，default_decompress_parms会把quantize_colors设为false，colormap设为NULL；jpeg_create_decompress会把progress设为NULL。&lt;br /&gt;
于是，此处相当于只执行了以下内容：&lt;/p&gt;
&lt;pre&gt;
    (*cinfo-&amp;gt;idct-&amp;gt;start_pass) (cinfo);
    (*cinfo-&amp;gt;coef-&amp;gt;start_output_pass) (cinfo);
    if (! cinfo-&amp;gt;raw_data_out) {
      if (! master-&amp;gt;using_merged_upsample)
	(*cinfo-&amp;gt;cconvert-&amp;gt;start_pass) (cinfo);
      (*cinfo-&amp;gt;upsample-&amp;gt;start_pass) (cinfo);
      if (cinfo-&amp;gt;quantize_colors)
	(*cinfo-&amp;gt;cquantize-&amp;gt;start_pass) (cinfo, master-&amp;gt;pub.is_dummy_pass);
      (*cinfo-&amp;gt;post-&amp;gt;start_pass) (cinfo,
	    (master-&amp;gt;pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
      (*cinfo-&amp;gt;main-&amp;gt;start_pass) (cinfo, JBUF_PASS_THRU);
}
&lt;/pre&gt;
&lt;p&gt;可以看出都是一些start pass。说明并不是实际的进行一些解码变换。否则应该叫idct-&amp;gt;process。&lt;br /&gt;
举个例子，idct-&amp;gt;start_pass注册为jddctmgr.c–start_pass，看一下大致的流程，仅仅是初始化一些查询表，不作解码动作。&lt;br /&gt;
raw_data_out在default_decompress_parms时被设为false，因此最终解码状态为DSTATE_SCANNING。如果手动设置了raw_data_out（见上(1)），那么此处可能是DSTATE_RAW_OK。&lt;br /&gt;
不管怎么说，jpeg_start_decompress就正确的返回了。&lt;/p&gt;

&lt;h2 id=&quot;jpeg_read_scanlinesjpeg_read_raw_data&quot;&gt;jpeg_read_scanlines/jpeg_read_raw_data&lt;/h2&gt;
&lt;p&gt;根据解码状态，显然接下去应该调用jpeg_read_scanlines解码。也有可能调用jpeg_read_raw_data解码。&lt;br /&gt;
如果要详细讲这两个函数，那么显然要了解jpeg的编码、解码方式。由于我的能力有限，暂未能详细了解jpeg的编解码流程，因此此处暂且不讲具体流程，仅仅简单的分析一下。&lt;br /&gt;
这两个函数处于jdapistd.c中，并且是紧挨着的两个函数。说明功能其实差不多。&lt;/p&gt;
&lt;h1 id=&quot;jpeg_read_scanlines&quot;&gt;jpeg_read_scanlines&lt;/h1&gt;
&lt;p&gt;调用process_data–process_data_simple_main。而process_data_simple_main调用decompress_data和post_process_data。&lt;/p&gt;
&lt;h1 id=&quot;jpeg_read_raw_data&quot;&gt;jpeg_read_raw_data&lt;/h1&gt;
&lt;p&gt;直接调用decompress_data。&lt;/p&gt;

&lt;h1 id=&quot;post_process_data&quot;&gt;post_process_data&lt;/h1&gt;
&lt;p&gt;虽然细节上还有差异，但显然差异就在于post_process_data。&lt;br /&gt;
post-&amp;gt;pub.post_process_data —- cinfo-&amp;gt;upsample-&amp;gt;upsample —- (jdsample.c)sep_upsample&lt;br /&gt;
sep_upsample中调用了两个接口，methods以及color_convert。methods是一些采样方法，暂且忽略。color_convert就是色彩空间的转换。&lt;br /&gt;
jinit_master_decompress-master_selection-jinit_color_deconverter中会根据输入的jpeg色彩空间以及输出的色彩空间（之前默认rgb），设置color_convert函数指针为&lt;br /&gt;
grayscale_convert&lt;br /&gt;
ycc_rgb_convert&lt;br /&gt;
gray_rgb_convert&lt;br /&gt;
null_convert&lt;br /&gt;
ycck_cmyk_convert&lt;br /&gt;
之一。那么如果要解码成JCS_YCbCr（见上(1)），输入又是JCS_YCbCr，那么显然调用jpeg_read_raw_data速度会更快。否则jpeg_read_scanlines会将yuv变换为rgb。后面又要通过rgb转换回yuv(demo写的不够好)。&lt;/p&gt;

&lt;h2 id=&quot;色彩空间&quot;&gt;色彩空间&lt;/h2&gt;
&lt;p&gt;上面这段demo支持rgb、gray、cmyk的解码。其中rgb和gray的解码效果基本没有差异，唯独cmyk有点缺陷。&lt;/p&gt;

&lt;p&gt;demo解码  :
&lt;img src=&quot;/images/libjpegmaterial/8.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;XnView解码  :
&lt;img src=&quot;/images/libjpegmaterial/9.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;windows照片查看器  :
&lt;img src=&quot;/images/libjpegmaterial/10.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ffplay CactiIslaPescado_ZH-CN11317505000_1920x1080_cmyk.jpg -x 1280 -y 720  :
&lt;img src=&quot;/images/libjpegmaterial/12.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;photoshop  :
&lt;img src=&quot;/images/libjpegmaterial/13.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看得出，除了photoshop和windows，其他的解码效果都与原图色彩较深。这是因为rgb于cmyk的转换并不是点对点的无损转换。
&lt;img src=&quot;/images/libjpegmaterial/14.jpg&quot; alt=&quot;avatar&quot; /&gt;&lt;/p&gt;

&lt;p&gt;有一种做法是将当前cmyk的色域扩充到lab色域。然后再缩回rgb色域。这样效果会较好（未经过验证）。&lt;/p&gt;

&lt;h2 id=&quot;jpeg_finish_decompressjpeg_destroy_decompress&quot;&gt;jpeg_finish_decompress/jpeg_destroy_decompress&lt;/h2&gt;
&lt;p&gt;一般来说，完成解码会调用这两个接口进行资源回收。但如果需要反复的解码，建议jpeg_create_decompress之前的代码只执行一次。此处只执行jpeg_finish_decompress，不执行jpeg_destroy_decompress。&lt;br /&gt;
jpeg_finish_decompress的内部会调用jpeg_abort进行一些资源回收。不调用jpeg_abort会出现内存泄漏问题。&lt;br /&gt;
jpeg_abort很奇怪的位于jcomapi.c中&lt;/p&gt;

&lt;p&gt;至此，一段简单的jpeg解码流程就结束了。欢迎和我讨论: pkokp8@gmail.com&lt;br /&gt;
编码流程有空继续补充。&lt;/p&gt;

</description>
				
				<pubDate>Mon, 05 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/libjpeg-decode-c</link>
				<guid isPermaLink="true">http://localhost:4000/libjpeg-decode-c</guid>
			</item>
			
		
			
			<item>
				<title>git的简单操作</title>
				
					<description>&lt;p&gt;
  记录一下git的使用。系统是ubuntu16.04. 安装好git环境  
  首先在github上右上角点一下+，然后New repository。  
  也可以本地创建好后push上去，不过这样也挺方便的。初学者嘛
&lt;/p&gt;

&lt;p&gt;
  然后是clone一个master，例如刚才创建的pkokp8.github.io.git分支
&lt;/p&gt;
&lt;pre&gt;
# git clone https://github.com/pkokp8/pkokp8.github.io.git
&lt;/pre&gt;

&lt;p&gt;接着就可以修改、提交文件&lt;/p&gt;
&lt;pre&gt;
# echo &quot;# test info&quot; &amp;gt;&amp;gt; README.md           #新建README.md
# git add .                                 #本地仓库新增这个文件
# git commit -m &quot;commit the readme&quot;         #提交到本地，日志为-m后面&quot;&quot;内的字符串。万一commit错误，可以不进行下一步，直接使用reset来回退代码，这样远端就不会有这次commit的记录
# git push -u origin master                 #push到远程主线。
&lt;/pre&gt;

&lt;p&gt;
  此时可能因为没有用户名和密码，会提示错误。可以配置后再执行上述命令
&lt;/p&gt;

&lt;pre&gt;
# git config --global user.name &quot;pkokp8&quot;
# git config --global user.email &quot;xxx@xx.com&quot;
&lt;/pre&gt;

&lt;p&gt;
  查看本地的提交记录，简单的可以使用。配合reset可以回退版本。注意-hard会把本地修改覆盖掉。  
  类似svn的svn revert ./ -R;svn up -r xxx
&lt;/p&gt;
&lt;pre&gt;
# git log
commit af17a9f424c5da5b4b06f90e69eb069f89124e40
Author: pkokp8 &amp;lt;xxx@xx.com&amp;gt;
Date:   Thu Mar 1 00:23:55 2018 +0800

    modify readme

# git reset -hard af17a9f424c5da5b4b06f90e69eb069f89124e40 
&lt;/pre&gt;

&lt;p&gt;
  接着就可以创建分支了：
&lt;/p&gt;
&lt;pre&gt;
# git branch firstversion                   #创建名为firstversion的分支
# git checkout firstversion                 #切换到这个分支
# git push -u origin firstversion           #把这个分支push到远端
# git checkout master                       #切换回主线
# git branch                                #查看当前处于哪条分支（看*），以及存在哪些分支
  firstversion
* master
# git diff                                  #查看本地与本地仓库之间的差异
&lt;/pre&gt;

&lt;p&gt;
  暂时就用到这么多。我感觉我还是要学习一个
&lt;/p&gt;
</description>
				
				<pubDate>Thu, 01 Mar 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/git-simple-use</link>
				<guid isPermaLink="true">http://localhost:4000/git-simple-use</guid>
			</item>
			
		
			
			<item>
				<title>复制一个list</title>
				
					<description>&lt;p&gt;初学python，爬图片的时候想复制一个list。一开始以为可以直接用这种方式复制list：
&lt;/p&gt;

&lt;pre&gt;
lista=[xxx, yyy, zzz]
listb=lista
&lt;/pre&gt;

&lt;p&gt;后来发现修改listb后lista的值也被修改了。原因是实际上listb就是lista。&lt;/p&gt;
&lt;p&gt;可以尝试用id函数打印出两个list的内存地址:&lt;/p&gt;
&lt;pre&gt;
lista = [0, 1, 2, 3, 4]
print(&quot;%s %s&quot; % (lista, id(lista)))

listb = lista
print(&quot;%s %s&quot; % (listb, id(listb)))

=============================
[0, 1, 2, 3, 4] 8246256
[0, 1, 2, 3, 4] 8246256

&lt;/pre&gt;

&lt;p&gt;
看得出，id相同。说明了两个list其实是同一个引用，这肯定不行。目的是为了新建一个list，同时修改新建的list不影响之前的list    
&lt;/p&gt;
&lt;p&gt;
有一种办法很粗暴：for循环遍历旧的list，新建一个空list，然后通过append方法把每一个元素添加进新的list。于是代码就是：
&lt;/p&gt;
&lt;pre&gt;
listnew=[]
for i in listold:
    listnew.append(i)
&lt;/pre&gt;
&lt;p&gt;
这个方法类似于在c语言中写出这样的代码:
&lt;/p&gt;
&lt;pre&gt;
char old[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
char new[10];
int i = 0;
for(i = 0;i &amp;lt; sizeof(old)/sizeof(char); i++)
{
	new[i] = old[i];
}
&lt;/pre&gt;
&lt;p&gt;你退群吧。除非要对数组每个成员进行处理，否则遍历有什么意义，memcpy()不行吗？&lt;/p&gt;
&lt;p&gt;而对于python来说，复制一个list有一些巧妙方法，例如：&lt;/p&gt;
&lt;pre&gt;
listnew = listold*1
&lt;/pre&gt;
&lt;p&gt;这里举点其他方法的例子：&lt;/p&gt;
&lt;pre&gt;
lista = [0, 1, 2, 3, 4]
print(&quot;a %s %s&quot; % (lista, id(lista)))

lista_ = lista					#实际没有复制
print(&quot;a_ %s %s&quot; % (lista_, id(lista_)))

'''
以下是复制
'''

listb = lista*1
print(&quot;b %s %s&quot; % (listb, id(listb)))

listc=[]
for i in lista:
    listc.append(i)				#append方法
print(&quot;c %s %s&quot; % (listc, id(listc)))

listd=[]
listd=lista[:]					#slice
print(&quot;d %s %s&quot; % (listd, id(listd)))

import copy
liste = copy.copy(lista)
print(&quot;e %s %s&quot; % (liste, id(liste)))

listf = [i for i in lista]			#列表生成式
print(&quot;f %s %s&quot; % (listf, id(listf)))


========================================
a [0, 1, 2, 3, 4] 40817648
a_ [0, 1, 2, 3, 4] 40817648
b [0, 1, 2, 3, 4] 40735088
c [0, 1, 2, 3, 4] 40817568
d [0, 1, 2, 3, 4] 40818648
e [0, 1, 2, 3, 4] 40818008
f [0, 1, 2, 3, 4] 40819608
&lt;/pre&gt;

&lt;p&gt;此外，如果list中带有list，list的拷贝就涉及了深拷贝和浅拷贝的知识点。不过这次先不考虑这个。还没到需要写list中带list的代码。用到了再学吧。&lt;/p&gt;
</description>
				
				<pubDate>Tue, 27 Feb 2018 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/python-copy-list</link>
				<guid isPermaLink="true">http://localhost:4000/python-copy-list</guid>
			</item>
			
		
			
			<item>
				<title>pass</title>
				
					<description>&lt;p&gt;;&lt;/p&gt;
</description>
				
				<pubDate>Sat, 01 Jan 2011 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/test1-test2-test3</link>
				<guid isPermaLink="true">http://localhost:4000/test1-test2-test3</guid>
			</item>
			
		
			
			<item>
				<title>pass</title>
				
					<description>&lt;p&gt;;&lt;/p&gt;
</description>
				
				<pubDate>Sat, 01 Jan 2011 00:00:00 +0800</pubDate>
				<link>http://localhost:4000/test1-test2-test3</link>
				<guid isPermaLink="true">http://localhost:4000/test1-test2-test3</guid>
			</item>
			
		
	</channel>
</rss>

