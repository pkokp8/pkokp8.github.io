---
layout:     post
title: uboot的网卡驱动
description: uboot的网卡驱动流程
category: blog
---
## uboot网卡驱动 ##

uboot的启动流程是这样的：  
cpu的片上rom会执行一段内部的代码，这段代码不可见、不可修改，一般是cpu厂家制作的。代码的功能是用来引导uboot。uboot的入口是start.S   
start.S中都是一些汇编，cpu厂家会根据自己的uboot调整里面的一些逻辑，但大致流程依然是跳转执行board.c中的C语言的代码。  
board.c的入口不确定。不同厂家会改接口名。例如sunxi的入口就是board_init_r，而海思则是start_armboot。要找到这个入口也很简单，因为一般没人改main.c--main_loop，谁调用了main_loop谁就是入口。  
不过这次不是讲uboot的启动流程，主要讲网卡驱动的驱动流程。  
+ sunxi平台
<pre>
board_init_r
	eth_initialize
		miiphy_init  //初始化一个mii_devs链表，并把current_mii指向NULL
		board_eth_init
			geth_initialize
				dev = (struct eth_device *)malloc(sizeof *dev);		//申请一个eth设备
				strcpy(dev->name, "eth0");							//命名为eth0
				random_ether_addr									//这个很有意思，随机产生一个mac地址
				//函数指针的初始化
				geth_sys_init										//sunxi平台会根据配置文件来初始化一些寄存器。
				eth_register										//注册一个eth。实际就是设定网卡结构体的状态等等。
				miiphy_register										//将mdio的操作注册进这个网卡结构体
</pre>




+ 海思平台
<pre>
start_armboot
	eth_initialize
		miiphy_init//把mii_devs放入链表
			stmmac_init//在do_ping中也有做这一步
				getenv("mdio_intf")
				getenv("phyaddr0"),sprintf(GMAC0_PHY_NAME, "mdio0");
				getenv("phyaddr1"),sprintf(GMAC1_PHY_NAME, "mdio1");
				stmmac_mdiobus_driver_init
					1.设置内存基地址（海思TOE）
					2.stmmac_mdio_clk_init
					3.miiphy_register
						list_for_each遍历链表找mii_devs
						比较链表节点（list_entry）的name和GMAC0_PHY_NAME是否相等，相等说明已注册，否则就未注册
						申请内存（设备）
						注册read和write函数//stmmac_mdiobus_read，stmmac_mdiobus_write
						把新申请的设备放入链表末尾（list_add_tail）
					4.设置当前mii设备
				stmmac_dev_probe_init
					stmmac_sys_init//写海思寄存器初始化
					stmmac_init_hw_desc_queue//写海思寄存器初始化
</pre>


至此，网卡的初始化流程就结束了。如果配置都ok，那么只要再实现一个ping命令或tftp命令，就可以和外界通信了。



## ping的流程 ##
uboot的ping命令非常简单。入口是do_ping。
用法和windows下或linux下是一样的。
do_ping首先把argv[1]赋值给NetPingIP，然后调用NetLoop(PING) 来初始化ping命令。

# NetLoop #
首先调用了eth_halt。然后设定网卡状态为ETH_STATE_PASSIVE。  
调用eth_halt的原因我认为是uboot没有进程调度、中断的概念，万一网卡还在工作，可能导致此次调用不成功。因此需要直接重新初始化一次网卡驱动。  
上面作了去初始化的操作，那么接下去一定会初始化网卡。

# eth_init #
<pre>
/* eth.c--eth_init */
		if (eth_current->init(eth_current,bis) >= 0) {		//实际调用geth_init
			eth_current->state = ETH_STATE_ACTIVE;
</pre>


# NetInitLoop #
初始化网卡之后，这里取一些ping命令过程需要用到的参数给全局变量。例如netmask，ourip、gatewayip等等

# PingStart #
获取到参数后，就需要发送ping消息了。这个接口是ping命令的实际工作函数的一小半。为什么说一小半呢？因为ping的流程是发送一个echo request，然后接收一个reply。并且发送request需要知道对端的mac地址。  
此处甚至不知道对方的mac地址，也就没有办法把ping包发出去。  

+ PingSend--NetSetEther(pkt, mac, PROT_IP);
这个函数的作用是封装ethernet帧的头部，此处是ping包的一部分的封装。  
<pre>
mac    ：目的host的mac，在这里全为0，因为现在只知道目的主机的ip，还不知道mac
PROT_IP: 该ethernet帧里封装的是IP包。ethernet帧分三种类型，根据ethernet的type来判断是哪种类型。
type:
PROT_IP 0x0800 /* IP protocol */
PROT_ARP 0x0806 /* IP ARP protocol */
PROT_RARP 0x8035 /* IP ARP protocol */
</pre>

+ 接下去继续封装icmp包：  
<pre>
	ip = (volatile IP_t *)pkt;

	/*
	 * Construct an IP and ICMP header.
	 * (need to set no fragment bit - XXX)
	 */
	/* IP_HDR_SIZE / 4 (not including UDP) */
	ip->ip_hl_v  = 0x45;
	ip->ip_tos   = 0;
	ip->ip_len   = htons(IP_HDR_SIZE_NO_UDP + 8);
	ip->ip_id    = htons(NetIPID++);
	ip->ip_off   = htons(IP_FLAGS_DFRAG);	/* Don't fragment */
	ip->ip_ttl   = 255;
	ip->ip_p     = 0x01;		/* ICMP */
	ip->ip_sum   = 0;
	/* already in network byte order */
	NetCopyIP((void *)&ip->ip_src, &NetOurIP);
	/* - "" - */
	NetCopyIP((void *)&ip->ip_dst, &NetPingIP);
	ip->ip_sum   = ~NetCksum((uchar *)ip, IP_HDR_SIZE_NO_UDP / 2);
		s = &ip->udp_src;		/* XXX ICMP starts here */
	s[0] = htons(0x0800);		/* echo-request, code */
	s[1] = 0;			/* checksum */
	s[2] = 0;			/* identifier */
	s[3] = htons(PingSeqNo++);	/* sequence number */
	s[1] = ~NetCksum((uchar *)s, 8/2);

	/* size of the waiting packet */
	NetArpWaitTxPacketSize =
		(pkt - NetArpWaitTxPacket) + IP_HDR_SIZE_NO_UDP + 8;

	/* and do the ARP request */
	NetArpWaitTry = 1;
	NetArpWaitTimerStart = get_timer(0);
</pre>

+ 最后ArpRequest发送一个arp请求  
调用NetSetEther(pkt, NetBcastAddr, PROT_ARP);  
以及一些赋值，封装一个arp报文，最后通过eth_send发送出去。  

+ eth_send
实际调用了geth_initialize初始化的geth_xmit函数。功能就是不断的读写寄存器来获取网卡内的数据。    



发送完arp包之后，就回到了NetLoop。发送了arp之后会通过miiphy_link读取一下phy的MII_BMSR寄存器判断一下是否是link状态。  
<pre>
#define MII_BMSR	    0x01	/* Basic mode status register  */
</pre>
如果此时读取寄存器错误或不是link状态，sunxi的boot就会点一下led灯来作指示。  


接下来就是ping的实际流程了。以下是一个死循环的开始  
while(1)  
{  
首先是eth_rx，内部调用了geth_recv。看名字是一个接收网卡数据的接口。实际上sunxi的boot在网卡中对这块封装的不是很好，不知道为什么这么写。  
这个接口不但有接收数据的操作(读写寄存器)，也有处理数据的操作(NetReceive)。  
第一次读取时刚发送了arp请求，因此这里先会获取到一个arpreplay(case ARPOP_REPLY)  
arp的作用是获取对端的物理地址(mac)  
接收到arpreply后就得到了对方的mac地址，发送ping的剩余的数据即可。  
<pre>
				(void) eth_send(NetArpWaitTxPacket,
						NetArpWaitTxPacketSize);
</pre>
这里NetArpWaitTxPacket在PingSend中已经初始化完成了，直接发送即可。  

NetLoop的第二次循环(不考虑失败情况)就应该能获取到ping的返回消息，也就是ICMP_ECHO_REPLY。这里很简单，调用了回调函数PingHandler，实际就是比较一下返回ip和argvp[1]的ip是否相等。相等时设定一下NetState为NETLOOP_SUCCESS。  

最后回到NetLoop，由于NetState状态被设为NETLOOP_SUCCESS，而NetBootFileXferSize在ping命令中一直为0.于是调用一下eth_halt关闭网卡，一个主要的ping流程就结束了。  
}  
根据返回的结果，打印“host argv[1] is alive\n”或者"ping failed; host argv[1] is not alive\n"  


## TODO ##
实际上整个boot只实现了这些简单的发送返回的功能。复杂一点的就是tftp了。tftp虽然是基于udp的协议，但boot并没有封装的那么详细。  
如果要实现一些tcp下的操作，只要了解tcp的消息构造，完全可以实现一个tcp的发送。（说的简单XD）  
实现tcp发送后，可以在tcp的基础上实现http服务。  
实现http服务后，就可以根据get、post等消息，实现一个不通过串口却能在boot下升级整个镜像的功能了。  
不过要做这些，工作量巨大。  





=========
即使不懂这些东西，有一个简单的框架，uip。了解一下  
游泳健身，了解一下  
