---
layout:     post
title: 两种无损变长编码
description: 哥伦布编码和哈夫曼编码
category: blog
---

最近看了下哥伦布编码，在此记录一下。  
正好上一次写了libjpeg的解码。jpeg的编解码中涉及了一种编解码算法，叫做哈夫曼编码。这里也顺便讲一下。  



## 一阶无符号指数哥伦布编码 ##
264/265的编解码中，一些码流信息是通过哥伦布编码的方式编进码流的。  
例如264的条带头解析中，表示IDR帧的序号是idr_pic_id，这个参数在264码流中是通过ue编码的，即无符号(u)指数(e)哥伦布编码  
哥伦布编码有很多种变种，此处只讲一下一阶无符号指数哥伦布编解码。  

# 编码 #
例如对20进行ue编码  
1.将X转换为二进制。20即10100。  
2.对该值进行加1计算。得到10101  
3.得到该二进制串的长度M。此处M=5  
4.在码流前补充M-1个0。此处得到000010101  

# 解码 #
接下来对上述编码完的数据进行解码。  
1.首先读取码流的连续N个0，直到遇到1为止。000010101有连续N=4个前导0
2.然后读取N+1位数据X。此处为10101
3.对X进行-1计算即得到了原始的码字。b(10101) - 1 = b(10100) = d(20)

可以看出，这是一种无损编解码方式。编解码过程中没有精度的丢失。  

# ffmpeg的哥伦布解码操作 #
先贴代码  
todo：注释  
<pre>
/* libavcodec/golomb.h */
static inline int get_ue_golomb(GetBitContext *gb)
{
    unsigned int buf;

    OPEN_READER(re, gb);
    UPDATE_CACHE(re, gb);
    buf = GET_CACHE(re, gb);

    if (buf >= (1 << 27)) {
        buf >>= 32 - 9;
        LAST_SKIP_BITS(re, gb, ff_golomb_vlc_len[buf]);
        CLOSE_READER(re, gb);

        return ff_ue_golomb_vlc_code[buf];
    } else {
        int log = 2 * av_log2(buf) - 31;
        LAST_SKIP_BITS(re, gb, 32 - log);
        CLOSE_READER(re, gb);
        if (CONFIG_FTRAPV && log < 0) {
            av_log(NULL, AV_LOG_ERROR, "Invalid UE golomb code\n");
            return AVERROR_INVALIDDATA;
        }
        buf >>= log;
        buf--;

        return buf;
    }
}
</pre>

# 哥伦布编码好处 #
与定长编码不同，哥伦布编码是一种变长编码。  
对于定长编码，举个例子，需要编码一个数字0和一个数字4  
假设数据处于0-255之间，那么可以使用unsigned char来存储这段数据  
0就会被编码成0000 0000  
4就会被编码成0000 0100  
于是生成了一段二进制码流0000 0000 0000 0100  
其中有效的信息是0和100  

那么对于哥伦布编码，会产生这样的码流：  
0会被编码成1  
4会被编码成00101  
于是得到了一段码流100101  

可见，码流长度被大大的缩减了。  
本来码流的长度是16个二进制位，现在只有6个。  

于是能得到一种结论：以后都用哥伦布编码不就行了？  
不行！  
哥伦布编码实际有效信息是除了前导0的部分，前导0是无效信息。而数字越小的部分，前导0越少，数字越大的部分，前导0越多。  
假设一个0和一个0xffff ffff需要被编码，用u32来表示就是32个0和32个1。总长度是64。  
但是用哥伦布编码就是1个1和32个0和1个1和32个0。结果总长度是66。  
看得出此时反而使用定长编码较好，编解码方式也简单。  

# 总结 #
那么什么时候可以用哥伦布编码呢？  
一开始我认为，当需要被编码的数据【大概率】处于较小的值时，可以用哥伦布编码。  
后来看到H264手册中存在类似这样的值：bit_depth_luma_minus8。这个值也是用哥伦布编码的。看到这个位的名字里有个minus8，虽然不知道这个值什么意思，但看名字应该是某个值-8后的值被编码了。  
于是我认为，只要被编码的数据【大概率】分布于【某个区间】时，就可以用哥伦布编码。  

这是因为，假如数据99.99%的概率存在于0xffff fff0 - 0xffff ffff之间，剩下的数据是0 - 0xffff ffef平均分布的。只要对所有待编码的数据减去0xffff fff0操作。那么待编码的数据就变成了99.99%的概率分布于0-f。约定解码后加上0xffff fff0即可。  




## 哈夫曼编码 ##

# 编码 #
假设有一段码流，为ABABDAABCD  

+ 统计各个码字出现的概率，并将码字按出现概率从大到小排序  

![avatar](/images/huffman/huffman3.jpg)

+ 选取出现概率最小的两个码字（DC），构建一个根节点。左子节点的值左边那个码字（D），右子节点是右边那个码字（C）。根节点的值(假设为E)为DC的值相加。E替换DC的位置。
![avatar](/images/huffman/huffman1.jpg)

+ 继续上述步骤，直到生成一个根节点的值为所有值相加(A+B+C+D)

+ 将所有左节点标记为0，右节点标记为1
![avatar](/images/huffman/huffman2.jpg)

+ 于是可以开始编码
A的编码为0  
B的编码为10  
C的编码为111  
D的编码为110  
ABABDAABCD的编码就是  
0100101100010111110  



# 解码 #
解码首先需要重建这颗haffman树。例如jpeg的DHT字段就含有重构huffman表的信息  
然后去读取编码后的码流0100101100010111110  
0是A，10是B，0是A，10是B，110是D，0是A，0是A，10是B，111是C，110是D  
于是得到ABABDAABCD的原始码流  

# 总结 #
haffman的思想是在haffman树上方的节点，其码字在整段码流中出现的概率高，编码后的长度短。下方的出现概率低，编码后的长度长。  







## 两种编码方式的总结 ##
哈夫曼编码与哥伦布编码的思想比较接近，通过特定的规则，将出现概率大的数字编码成较短的码流。以达到减少数据量的目的。  






